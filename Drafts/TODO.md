DateFormat


Celllayout 
构造函数
mTouchFeedbackView为按下时图标表面一层透明灰色动画效果。
addView(mTouchFeedbackView, (int) (grid.cellWidthPx * 1.5), (int) (grid.cellHeightPx * 1.5));
addView(mShortcutsAndWidgets);

CellLayout-addView(ShortcutAndWidgetContainer view)

拖动时shake动画
ReorderPreviewAnimation-animate()

CellLayout-LayoutParams 
boolean[][] mOccupied 桌面图标布局中是否有图标占位，存在为true
CellLayout-addViewToCellLayout方法赋值，这个方法在Workspace-addInScreen方法中调用，而桌面初始化时的bind过程会一直调用到这个方法。

CellLayout-performReorder()
CellLayout-findReorderSolution()
CellLayout-rearrangementExists()

CellLayout-attemptPushInDirection()
xy方向上均有作用力，先pushViewsToTempLocation()移动x轴，再移动y轴，若正方向上移动失败，换方向，若只有一个方向有作用力，以以下顺序推动，正方向，反方向，xy轴互换，xy轴互换反方向。
CellLayout-addViewsToTempLocation Views
推力没有成功，试着将Views整体移动到空位
CellLayout-addViewToTempLocation View
整体移动失败，试着单独移动

CellLayout-pushViewToTempLocation()
ViewCluster,记录了上下左右边上当前影响的Views的边界位置，用来表示Rect区域和别的Cell的关系。

拖动图标到新的位置时所引起的图标重排，受影响的图标会有一个shake的动画效果

拖动图标的事件处理
DragController和DragLayer
DragLayer是Launcher3中处理拖动图标事件时自定义View，DragController的注释为：发起一个在一个View内或在几个View之间拖动事件的类。从名字可以看出这个类是一个调节者或控制者。
在DragLayer-onInterceptTouchEvent方法将事件给DragController-onInterceptTouchEvent方法处理。拖动拖图的事件开始处理时，会一直调用到DragController-startDrag方法，此时，startDrag里将mDragging置为true,而DragController-onInterceptTouchEvent返回mDragging,此时截断事件传递，当前View处理触摸事件。类似的，DragLayer的onTouchEent方法也将事件给DragController的onTouchEent方法处理。

handleMoveEvent方法为处理触摸事件的主要方法，在handleMoveEvent方法中调用findDropTarget取的当前的具体的DropTarget对象，DragController中有一个mDropTargets链表，这个链表中在桌面的加载和操作会包含进来具体DropTarget对象，在Launcher3中，实现DropTarget类的有Folder和Workspace等，这个interface抽象了拖动时落点对象。DropTarget-isDropEnabled方法，表示当前这个落点View是否可以Drop，当该方法返回false时，显然是不能将拖动的Object放到这里来的。checkTouchMove方法检查拖动时的状态，根据拖动时DropTarget之间的关系调用DropTarget声明的onDrop，onDragEnter,onDragExit,onDragOver方法进行视图的演示，最后调用checkScrollState方法，这个方法主要是对拖动时的翻页进行判断处理。

接下来主要分析DropTarget为Workspace的拖动。

根据checkTouchMove方法，在Workspace中开始拖动图标时，图标开始时在Workspace中，此时DropTarget也为Workspace，所以刚开始时调用Workspace的onDragEnter方法，紧接着调用Workspace的onDragOver方法。而onDragExit方法的调用时机为拖动的Cell离开当前Target，当前Target变为为mLastDropTarget，又没有进入一个有效的Target时。
Workspace的onDragEnter方法，这个方法比较简单，对Workspace的拖动时的涉及到的变量进行了初始化。
Workspace的onDragOver方法，在Workspace中有一个mDragViewVisualCenter变量，根据字面理解，这个变量是拖动对象的视觉中心位置，由getDragViewVisualCenter方法计算而来，在对拖动处理时使用到多处，此外拖动的时候也要判断当前位置Layout的是处于翻动的页面还是Hotseat中，确定mDragTargetLayout。接着findNearestArea方法根据mDragViewVisualCenter先大致当前的落点，findNearestArea方法会调用到Celllayout的findNearestArea方法，根据不同情况在调用的过程中会分别考虑和不考虑当前页面的其他item的占用情况。确定了可能的落点后首先对Folder情况进行处理，分新建和加入已有的Folder两种，然后是落点已经被其他的Item占据的情况，这里调用performReorder方法处理，这个方法相当长，拖动过程中和结束拖动放下时的onDrag方法中都会调用这个方法，拖动过程中图标的重排效果就是在此方法中实现的。
Workspace的onDragExit方法，根据上面onDragExit的调用时机，这里主要确定拖动图标离开有效DragTarget时最后的落点。

根据DragController的onTouchEent方法，触摸事件为MotionEvent.ACTION_UP时，拖动事件结束，这时有两种可能：当满足快速向上扔时，删除拖动的item，isFlingingToDelete方法判断条件是否满足。如果不满足扔的条件，调用drop方法，drop方法调用DropTarget的acceptDrop方法，判断该Drop事件是否发生，依此调用DropTarget的onDrop方法。
Workspace-onDrop()流程
方法参数为DropTarget-DragObject对象，首先计算拖动View的视觉中心mDragViewVisualCenter，dropTargetLayout为Drop的Celllayout对象，下一步判断当前是否在Hotseat上，求出相对于dropTargetLayout的视觉中心坐标。如果DragObject-dragSource！=Worspace，转而调用onDropExternal()，否则继续处理onDrop()的内容。接着调用findNearestArea方法球drop的xy的值，Workspace-findNearestArea()调用到CellLayout-findNearestArea(),该方法是一个重要的方法，作用是找到离落点最近距离cell，其中有一个boolean参数ignoreOccupied，当ignoreOccupied为false时，寻找cell时不考虑已经占据的区域，为true时考虑。
接下来开始处理落点和文件夹的关系,如果落点处可以合成一个Folder，调用Workspace-createUserFolderIfNecessary()方法，如果拖动的图标可以加进一个文件夹，则调用Workspace-addToExistingFolderIfNecessary()方法。
如果不满足文件夹的条件，则调用CellLayout-performReorder方法，这个方法就是处理拖动图标时，如果当前落点被占据时，挤开当前图标的效果。AppWidget可能在拖动时发生缩小，因此会调用AppWidgetResizeFrame-updateWidgetSizeRanges方法，拖动时可能落点在别的页面，所以还会有页面滑动的效果。如果满足则更新位置，保存新的位置信息到数据库中，播放动画效果，否则弹回原来位置。

acceptDrop方法的调用过程和逻辑和onDrop方法差不多，需要注意的是调用performReorder方法时mode参数不同。

除了DropTarget，WorkSpace还implements了DragController.DragListener，DragCtroller中存在一个mListeners链表，在桌面加载时会将相应的对象加进来，比如Workspace在Launcher的setupViews方法中加入。这个接口声明了onDragStart方法和onDragEnd方法,上面说过开始拖动时调用DragController的startDrag方法,startDrag方法中依次调用mListeners中对象的onDragStart方法，这里处理的是开始拖动时桌面受影响的View对象，比如刚开始拖动时Workspace有一些提示效果，搜索删除按钮(SearchDropTargetBar)会由搜索界面变为删除等，这些View对象都是继承了这个借口的。除此之外，startDrag方法还显示了拖动item的DragView。
Workspace的onDragStart方法处理了一些界面相关的操作，比如锁定屏幕方向，生成额外的空白页等。onDragEnd方法即为相反的操作。

Workspace还实现了一个拖动相关的接口为DragSource接口，这个接口定义了拖动可以从它本身开始的对象，就是可以从Workspace开始拖动一个图标，DragSorce声明了一系列拖动时判断条件或某种状态回调的方法。

方法：

dragSource != this
onDropExternal()

findNearestArea()此时没有考虑位置是否被占
createUserFolderIfNecessary()
addToExistingFolderIfNecessary()

performReorder()

getDirectionVectorForDrop()用一个int数组direction来计算dragView推动别的View的力
getViewsIntersectingRegion()求出现在dragView影响的区域的Views，drop区域的Rect


