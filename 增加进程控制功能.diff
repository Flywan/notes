Index: frameworks/base/Android.mk
===================================================================
--- frameworks/base/Android.mk	(revision 5726)
+++ frameworks/base/Android.mk	(revision 5734)
@@ -399,6 +399,8 @@
 	packages/services/PacProcessor/com/android/net/IProxyService.aidl \
 	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
 	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
+	core/java/com/topwise/appcheck/IAppChecker.aidl \
+	core/java/com/topwise/appcheck/IAppCheckStoreObserver.aidl \
 	telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl \
 
 #add for heartbeat powerguru
@@ -692,6 +694,7 @@
 	frameworks/base/core/java/android/database/CursorWindow.aidl \
 	frameworks/base/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl \
 	frameworks/base/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl \
+	frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.aidl \
 	frameworks/base/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
 
 
Index: frameworks/base/core/java/com/android/internal/appwidget/IAppWidgetService.aidl
===================================================================
--- frameworks/base/core/java/com/android/internal/appwidget/IAppWidgetService.aidl	(revision 5726)
+++ frameworks/base/core/java/com/android/internal/appwidget/IAppWidgetService.aidl	(revision 5734)
@@ -66,5 +66,7 @@
             in IBinder connection);
     void unbindRemoteViewsService(String callingPackage, int appWidgetId, in Intent intent);
     int[] getAppWidgetIds(in ComponentName providerComponent);
+    //FEATURE_STOP_APPS for force stop app to get all enable widget
+    List<AppWidgetProviderInfo> getEnableWidgetProviderInfos();
 }
 
Index: frameworks/base/core/java/com/topwise/appcheck/AppCheckerManager.java
===================================================================
--- frameworks/base/core/java/com/topwise/appcheck/AppCheckerManager.java	(revision 0)
+++ frameworks/base/core/java/com/topwise/appcheck/AppCheckerManager.java	(revision 5734)
@@ -0,0 +1,150 @@
+package com.topwise.appcheck;
+
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.text.TextUtils;
+
+import com.topwise.appcheck.IAppChecker;
+import com.topwise.appcheck.AppCheckerInfo;
+
+import java.util.List;
+
+/**
+ * Created by huangxunwan on 9/28/16.
+ */
+public final class AppCheckerManager {
+
+    public final static int SHORT_LEVEL = 1;
+    public final static int MEDIUM_LEVEL = 2;
+    public final static int LONG_LEVEL = 3;
+    public final static int SUPERLONG_LEVEL = 4;
+    public final static int NO_CHECK_LEVEL = 5;
+    /**
+    *@hide
+    * not control in appchecker, consist of sys apps donot in SysAppToKill, exclude 3rdapp and persist app
+    */
+    public final static int EXCLUDE_LEVEL = -1;
+
+    private static AppCheckerManager sInstance;
+    private static IAppChecker sService;
+
+    private AppCheckerManager(){
+        if (sService == null){
+            IBinder binder = ServiceManager.getService("appchecker");
+            sService = IAppChecker.Stub.asInterface(binder);
+        }
+    }
+
+    public static AppCheckerManager getInstance() {
+        synchronized (AppCheckerManager.class) {
+            if (sInstance != null) {
+                return sInstance;
+            }
+            sInstance = new AppCheckerManager();
+        }
+        return sInstance;
+    }
+
+    public int getLevel(String pkgName){
+        int result = -1;
+        if (TextUtils.isEmpty(pkgName)){
+            return result;
+        }
+        try {
+            result = sService.getLevel(pkgName);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+    public void setLevel(String pkgName, int level){
+        try {
+            sService.setLevel(pkgName, level);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+    public List<AppCheckerInfo> getLevelList(int level){
+        List<AppCheckerInfo> result = null;
+        try {
+            result = sService.getLevelList(level);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+
+    public List<AppCheckerInfo> getForceStopList(){
+        List<AppCheckerInfo> result = null;
+        try {
+            result = sService.getForceStopList();
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+
+    public List<AppCheckerInfo> getExcludeList(){
+        List<AppCheckerInfo> result = null;
+        try {
+            result = sService.getExcludeList();
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+    public List<AppCheckerInfo> getSysBlackList(){
+        List<AppCheckerInfo> result = null;
+        try {
+            result = sService.getSysBlackList();
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return result;
+    }
+    public void setAutoBootEnabled(String pkgName, boolean state){
+        try {
+            sService.setAutoBootEnabled(pkgName, state);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public int getLevelTime(int level){
+        try{
+            return sService.getLevelTime(level); 
+        }catch (RemoteException e) {
+            e.printStackTrace();
+        }
+
+        return 15;
+    }
+
+    public void setLevelTime(String levelTime){
+        try{
+            sService.setLevelTime(levelTime);
+        }catch (RemoteException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    public void registerCheckerObserver(IAppCheckStoreObserver observer){
+        try {
+            sService.registerCheckerObserver(observer);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void resetAppCheckerInfo(){
+        try {
+            sService.resetAppCheckerInfo();
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+
+}
+
Index: frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.java
===================================================================
--- frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.java	(revision 0)
+++ frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.java	(revision 5734)
@@ -0,0 +1,70 @@
+package com.topwise.appcheck;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class AppCheckerInfo implements Parcelable {
+    public String packageName;
+    public int level;
+    public int bootKill;
+
+    public AppCheckerInfo(String name, int level, int flag) {
+        packageName = name;
+        this.level = level;
+        bootKill = flag;
+    }
+
+    public boolean isBootKill(){
+      return bootKill == 1;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int parcelableFlags) {
+        dest.writeString(packageName);
+        dest.writeInt(level);
+        dest.writeInt(bootKill);
+    }
+
+    public static final Parcelable.Creator<AppCheckerInfo> CREATOR
+            = new Parcelable.Creator<AppCheckerInfo>() {
+        @Override
+        public AppCheckerInfo createFromParcel(Parcel source) {
+            return new AppCheckerInfo(source);
+        }
+
+        @Override
+        public AppCheckerInfo[] newArray(int size) {
+            return new AppCheckerInfo[size];
+        }
+    };
+
+    private AppCheckerInfo(Parcel source) {
+        packageName = source.readString();
+        level = source.readInt();
+        bootKill = source.readInt();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public String toString() {
+        return "AppCheckerInfo: [" + packageName + "-" 
+                        + level + "-" + bootKill
+                        + "]";
+    }
+
+    @Override
+    public boolean equals(Object anObject) {
+        if (this == anObject) {
+            return true;
+        }
+        if (packageName != null && anObject instanceof AppCheckerInfo 
+                && packageName.equals(((AppCheckerInfo)anObject).packageName)){
+            return true;
+        }
+        return false;
+    }
+}
Index: frameworks/base/core/java/com/topwise/appcheck/IAppCheckStoreObserver.aidl
===================================================================
--- frameworks/base/core/java/com/topwise/appcheck/IAppCheckStoreObserver.aidl	(revision 0)
+++ frameworks/base/core/java/com/topwise/appcheck/IAppCheckStoreObserver.aidl	(revision 5734)
@@ -0,0 +1,8 @@
+package com.topwise.appcheck;
+
+import com.topwise.appcheck.AppCheckerInfo;
+
+oneway interface IAppCheckStoreObserver {
+    void appStoreChange(in boolean reset, in AppCheckerInfo info, in int oldLevel, in int newLevel, in boolean bootStart);
+}
+
Index: frameworks/base/core/java/com/topwise/appcheck/IAppChecker.aidl
===================================================================
--- frameworks/base/core/java/com/topwise/appcheck/IAppChecker.aidl	(revision 0)
+++ frameworks/base/core/java/com/topwise/appcheck/IAppChecker.aidl	(revision 5734)
@@ -0,0 +1,20 @@
+package com.topwise.appcheck;
+
+import com.topwise.appcheck.IAppCheckStoreObserver;
+import com.topwise.appcheck.AppCheckerInfo;
+
+interface IAppChecker {
+    int getLevel(String pkgName);
+    void setLevel(String pkgName, int level);
+    List<AppCheckerInfo> getLevelList(int level);
+    int getLevelTime(int level);
+    List<AppCheckerInfo> getForceStopList();
+    List<AppCheckerInfo> getExcludeList();
+    List<AppCheckerInfo> getSysBlackList();
+    List<AppCheckerInfo> getPersistList();
+    List<AppCheckerInfo> getNoPersistList();
+    void setAutoBootEnabled(String pkgName, boolean state);
+    void registerCheckerObserver(IAppCheckStoreObserver observer);
+    void resetAppCheckerInfo();
+    void setLevelTime(String levelTime);
+}
Index: frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.aidl
===================================================================
--- frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.aidl	(revision 0)
+++ frameworks/base/core/java/com/topwise/appcheck/AppCheckerInfo.aidl	(revision 5734)
@@ -0,0 +1,3 @@
+package com.topwise.appcheck;
+
+parcelable AppCheckerInfo;
Index: frameworks/base/core/java/android/app/JobSchedulerImpl.java
===================================================================
--- frameworks/base/core/java/android/app/JobSchedulerImpl.java	(revision 5726)
+++ frameworks/base/core/java/android/app/JobSchedulerImpl.java	(revision 5734)
@@ -69,4 +69,13 @@
             return null;
         }
     }
+
+     //added by lixuhui 2016/1/22 cancel the jobs for uid
+    @Override
+    public void cancelJobsForUid(int uid){
+        try {
+            mBinder.cancelJobsForUid(uid);
+        } catch (RemoteException e) {}
+    }
+    //end
 }
Index: frameworks/base/core/java/android/app/job/JobScheduler.java
===================================================================
--- frameworks/base/core/java/android/app/job/JobScheduler.java	(revision 5726)
+++ frameworks/base/core/java/android/app/job/JobScheduler.java	(revision 5734)
@@ -85,4 +85,12 @@
      */
     public abstract List<JobInfo> getAllPendingJobs();
 
+    /**
+     * added by lixuhui 2016/01/22 cancel the jobs about the uid
+     * @hide
+     */
+    public abstract void cancelJobsForUid(int uid);
+
+
+
 }
Index: frameworks/base/core/java/android/app/job/IJobScheduler.aidl
===================================================================
--- frameworks/base/core/java/android/app/job/IJobScheduler.aidl	(revision 5726)
+++ frameworks/base/core/java/android/app/job/IJobScheduler.aidl	(revision 5734)
@@ -27,4 +27,7 @@
     void cancel(int jobId);
     void cancelAll();
     List<JobInfo> getAllPendingJobs();
+    //added by lixuhui 2016/01/22 cancel the jobs about uid
+    void cancelJobsForUid(int uid);
+    //end
 }
Index: frameworks/base/core/java/android/content/Context.java
===================================================================
--- frameworks/base/core/java/android/content/Context.java	(revision 5726)
+++ frameworks/base/core/java/android/content/Context.java	(revision 5734)
@@ -2147,6 +2147,7 @@
             MEDIA_SESSION_SERVICE,
             BATTERY_SERVICE,
             JOB_SCHEDULER_SERVICE,
+			"appchecker",
             MEDIA_PROJECTION_SERVICE,
     })
     @Retention(RetentionPolicy.SOURCE)
Index: frameworks/base/core/java/android/content/pm/PackageUserState.java
===================================================================
--- frameworks/base/core/java/android/content/pm/PackageUserState.java	(revision 5726)
+++ frameworks/base/core/java/android/content/pm/PackageUserState.java	(revision 5734)
@@ -37,6 +37,10 @@
     public ArraySet<String> disabledComponents;
     public ArraySet<String> enabledComponents;
 
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    public boolean killed;
+    //end
+
     public PackageUserState() {
         installed = true;
         hidden = false;
@@ -55,5 +59,6 @@
         enabledComponents = o.enabledComponents != null
                 ? new ArraySet<String>(o.enabledComponents) : null;
         blockUninstall = o.blockUninstall;
+        killed = o.killed;  //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
     }
 }
Index: frameworks/base/core/java/android/content/pm/IPackageManager.aidl
===================================================================
--- frameworks/base/core/java/android/content/pm/IPackageManager.aidl	(revision 5726)
+++ frameworks/base/core/java/android/content/pm/IPackageManager.aidl	(revision 5734)
@@ -468,4 +468,7 @@
     KeySet getSigningKeySet(String packageName);
     boolean isPackageSignedByKeySet(String packageName, in KeySet ks);
     boolean isPackageSignedByKeySetExactly(String packageName, in KeySet ks);
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    void setPackageKilledState(String packageName, boolean killed, int userId);
+    //end
 }
Index: frameworks/base/core/java/android/content/pm/PackageParser.java
===================================================================
--- frameworks/base/core/java/android/content/pm/PackageParser.java	(revision 5726)
+++ frameworks/base/core/java/android/content/pm/PackageParser.java	(revision 5734)
@@ -92,6 +92,10 @@
 
 import java.lang.ref.WeakReference;
 
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+
 /** @} */
 
 /**
@@ -2641,7 +2645,9 @@
 
                     if (!pkgName.contains("android") &&
                         !pkgName.contains("mediatek") &&
-                        !pkgName.contains(".mtk.")) {
+                        !pkgName.contains(".mtk.") &&
+                        !pkgName.contains(".tpw.") &&
+                        !pkgName.contains(".topwise.")) {
                         break;
                     }
 
@@ -4813,6 +4819,7 @@
             ai.enabled = false;
         }
         ai.enabledSetting = state.enabled;
+        ai.killed = state.killed;  //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
     }
 
     public static ApplicationInfo generateApplicationInfo(Package p, int flags,
@@ -5528,4 +5535,5 @@
         return enabled ;
     }
     /// @}
+
 }
Index: frameworks/base/core/java/android/content/pm/ApplicationInfo.java
===================================================================
--- frameworks/base/core/java/android/content/pm/ApplicationInfo.java	(revision 5726)
+++ frameworks/base/core/java/android/content/pm/ApplicationInfo.java	(revision 5734)
@@ -422,6 +422,14 @@
      */
     public int flagsEx = 0;
 
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    /**
+     * add this property to control the application is killed by topwise or not
+     * {@hide}
+     */
+    public boolean killed = false;
+    //end
+
     /**
      * The required smallest screen width the application can run on.  If 0,
      * nothing has been specified.  Comes from
@@ -738,6 +746,7 @@
         descriptionRes = orig.descriptionRes;
         uiOptions = orig.uiOptions;
         backupAgentName = orig.backupAgentName;
+        killed = orig.killed;    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
     }
 
 
@@ -791,6 +800,7 @@
         dest.writeString(backupAgentName);
         dest.writeInt(descriptionRes);
         dest.writeInt(uiOptions);
+        dest.writeInt(killed ? 1 : 0);   //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
     }
 
     public static final Parcelable.Creator<ApplicationInfo> CREATOR
@@ -843,6 +853,7 @@
         backupAgentName = source.readString();
         descriptionRes = source.readInt();
         uiOptions = source.readInt();
+        killed = source.readInt() != 0;   //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped statu
     }
 
     /**
Index: frameworks/base/media/java/android/media/FocusRequester.java
===================================================================
--- frameworks/base/media/java/android/media/FocusRequester.java	(revision 5726)
+++ frameworks/base/media/java/android/media/FocusRequester.java	(revision 5734)
@@ -325,4 +325,14 @@
         return new AudioFocusInfo(mAttributes, mClientId, mPackageName,
                 mFocusGainRequest, mFocusLossReceived, mGrantFlags);
     }
+    //lixuhui add 2015/08/22 for smart detect app function
+    String getPackageName(){
+        return mPackageName;
+    }
+
+    int getFocusLossReceived(){
+        return mFocusLossReceived;
+    }
+    //end
+
 }
Index: frameworks/base/media/java/android/media/MediaFocusControl.java
===================================================================
--- frameworks/base/media/java/android/media/MediaFocusControl.java	(revision 5726)
+++ frameworks/base/media/java/android/media/MediaFocusControl.java	(revision 5734)
@@ -2204,5 +2204,39 @@
         // in the stack. This is now in MediaSessionService. More code should be
         // removed.
     }
+	
+    //lixuhui add 2015/08/22 for smart detect app function
+    protected String getCurrentAudioFocusPackage(){
+        synchronized(mAudioFocusLock) {
+            isInCallNow = false;
+            if (mFocusStack.empty()) {
+                return null;
+            } else {
+                int size = mFocusStack.size();
+                boolean isInCall = false;
+                for(int index = size - 1; index >= 0; --index){
+                    FocusRequester focusStack = mFocusStack.get(index);
+                    if(focusStack.getGainRequest() == AudioManager.AUDIOFOCUS_GAIN || focusStack.getGainRequest() == AudioManager.AUDIOFOCUS_GAIN_TRANSIENT){
+                        String packageName = focusStack.getPackageName();
+                        if("com.android.server.telecom".equals(packageName)){
+                            isInCall = true;
+                            isInCallNow = true;
+                            continue;
+                        }
+                        if(isInCall && (focusStack.getFocusLossReceived() != AudioManager.AUDIOFOCUS_LOSS_TRANSIENT)){
+                            continue;
+                        }
+                        return packageName;
+                    }
+                }
+                return null;
+            }
+        }
+    }
+    private boolean isInCallNow = false;
+    protected boolean isInCall(){
+        return isInCallNow;
+    }
+    //end
 
 }
Index: frameworks/base/media/java/android/media/IAudioService.aidl
===================================================================
--- frameworks/base/media/java/android/media/IAudioService.aidl	(revision 5726)
+++ frameworks/base/media/java/android/media/IAudioService.aidl	(revision 5734)
@@ -235,4 +235,9 @@
     void setAudioProfileStreamVolume(int streamType, int index, int flags);
 
     oneway void listenRingerModeAndVolume(IAudioProfileListener callback, int event);
+    //lixuhui add 2015/08/22 for smart detect app function
+    String getCurrentAudioFocusPackageName();
+    boolean isInCall();
+    //end
+
 }
Index: frameworks/base/media/java/android/media/AudioService.java
===================================================================
--- frameworks/base/media/java/android/media/AudioService.java	(revision 5726)
+++ frameworks/base/media/java/android/media/AudioService.java	(revision 5734)
@@ -6496,4 +6496,15 @@
         return isSmartBookConnected;
     }
     /// @}
+	
+	//lixuhui add 2015/08/22 for smart detect app function
+    public String getCurrentAudioFocusPackageName(){
+        return mMediaFocusControl.getCurrentAudioFocusPackage();
+    }
+
+    public boolean isInCall(){
+        return mMediaFocusControl.isInCall();
+    }
+    //end
+
 }
Index: frameworks/base/media/java/android/media/AudioManager.java
===================================================================
--- frameworks/base/media/java/android/media/AudioManager.java	(revision 5726)
+++ frameworks/base/media/java/android/media/AudioManager.java	(revision 5734)
@@ -3906,4 +3906,31 @@
              Log.e(TAG, "Dead object in listenRingerModeAndVolume", e);
          }
      }
+    //lixuhui add 2015/08/22 for smart detect app function
+    /**
+     * @hide
+     * */
+    public String getCurrentAudioFocusPackageName(){
+        IAudioService service = getService();
+        try {
+            return service.getCurrentAudioFocusPackageName();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getCurrentAudioFocusPackageName", e);
+            return null;
+        }
+    }
+
+    /**
+     * @hide
+     * */
+    public boolean isInCall(){
+        IAudioService service = getService();
+        try {
+            return service.isInCall();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getCurrentAudioFocusPackageName", e);
+            return false;
+        }
+    }
+    //end
 }
Index: frameworks/base/services/java/com/android/server/SystemServer.java
===================================================================
--- frameworks/base/services/java/com/android/server/SystemServer.java	(revision 5726)
+++ frameworks/base/services/java/com/android/server/SystemServer.java	(revision 5734)
@@ -149,6 +149,8 @@
 import com.mediatek.hdmi.MtkHdmiManagerService;
 /// @}
 
+import com.topwise.appchecker.AppCheckerService;
+
 public final class SystemServer {
     private static final String TAG = "SystemServer";
 
@@ -1076,6 +1078,7 @@
             mSystemServiceManager.startService(UiModeManagerService.class);
 
             mSystemServiceManager.startService(JobSchedulerService.class);
+            mActivityManagerService.setCheckerService(mSystemServiceManager.startService(AppCheckerService.class));
 
             if (!disableNonCoreServices) {
                 if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
Index: frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java
===================================================================
--- frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java	(revision 5726)
+++ frameworks/base/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java	(revision 5734)
@@ -4175,4 +4175,17 @@
             }
         }
     }
+
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    @Override
+	public List<AppWidgetProviderInfo> getEnableWidgetProviderInfos(){
+        ArrayList<AppWidgetProviderInfo> providerInfos = new ArrayList<AppWidgetProviderInfo>();
+        for(Widget widget : mWidgets){
+            if(widget != null && widget.provider != null && widget.provider.info != null){
+                providerInfos.add(cloneIfLocalBinder(widget.provider.info));
+            }
+        }
+        return providerInfos;
+    }
+    //end
 }
Index: frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java	(revision 5734)
@@ -266,6 +266,8 @@
 import android.provider.Settings;
 //end:fanxiangjian,forbid wallpaper in restore
 
+import com.topwise.appchecker.AppCheckerService;
+
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
 
@@ -1380,9 +1382,6 @@
     static final int SEND_LOCALE_TO_MOUNT_DAEMON_MSG = 47;
     static final int DISMISS_DIALOG_MSG = 48;
     static final int NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG = 49;
-    //start;fanxiangjian,forbid wallpaper in restore
-    static final int NOTIFY_FORBID_WALLPAPER_END_MSG = 60;
-    //end:fanxiangjian,forbid wallpaper in restore
 
     static final int FIRST_ACTIVITY_STACK_MSG = 100;
     static final int FIRST_BROADCAST_QUEUE_MSG = 200;
@@ -1416,19 +1415,6 @@
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
-            //start;fanxiangjian,forbid wallpaper in restore
-            case NOTIFY_FORBID_WALLPAPER_END_MSG: 
-		{
-			try{
-				Settings.System.putInt(mContext.getContentResolver(),"first_launch_finish",1);
-				Log.d("WallpaperManager","server first_launch_finish");
-			}catch(Exception e){
-				Log.d("WallpaperManager","server Exception "+e);
-			}
-            	}
-		break;
-	//end:fanxiangjian,forbid wallpaper in restore
-
             case SHOW_ERROR_MSG: {
                 HashMap<String, Object> data = (HashMap<String, Object>) msg.obj;
                 boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),
@@ -3543,8 +3529,12 @@
 	if(android.os.TopwiseProp.getDefaultSettingBoolean("forbid_wallpaper_before_startup",false)){
 		int finish = Settings.System.getInt(mContext.getContentResolver(),"first_launch_finish",0);
 		if(finish==0){
-			   int delay=android.os.TopwiseProp.getDefaultSettingInt("forbid_wallpaper_message_delay",3000);
-		            mHandler.sendMessageDelayed(mHandler.obtainMessage(NOTIFY_FORBID_WALLPAPER_END_MSG),delay);
+			try{
+				Settings.System.putInt(mContext.getContentResolver(),"first_launch_finish",1);
+				Log.d("WallpaperManager","server first_launch_finish");
+			}catch(Exception e){
+				Log.d("WallpaperManager","server Exception "+e);
+			}
 		}
 	}
 	//end:fanxiangjian,forbid wallpaper in restore
@@ -6304,7 +6294,7 @@
         }
     }
 
-    private void forceStopPackageLocked(final String packageName, int uid, String reason) {
+    public void forceStopPackageLocked(final String packageName, int uid, String reason) {
         forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false,
                 false, true, false, false, UserHandle.getUserId(uid), reason);
         Intent intent = new Intent(Intent.ACTION_PACKAGE_RESTARTED,
@@ -6413,6 +6403,11 @@
                         /// @}
                         continue;
                     }
+                    //FEATURE_STOP_APPS added by lixuhui 2015/12/09 do not kill the app which is foreground app when force stop
+                    if(reason != null && reason.startsWith("TPW-") && UserHandle.getAppId(app.uid) != appId && isDep){
+                        continue;
+                    }
+                    //end
                     if (userId != UserHandle.USER_ALL && app.userId != userId) {
                         /// M: AMS log enhancement @{
                         if (!IS_USER_BUILD)
@@ -6516,9 +6511,14 @@
             }
         }
 
-        boolean didSomething = killPackageProcessesLocked(name, appId, userId,
-                -100, callerWillRestart, doRestartAfterForceStop(reason), doit, evenPersistent,
-                name == null ? ("stop user " + userId) : ("stop " + name));
+        //FEATURE_STOP_APPS added by lixuhui 2015/12/09 do not kill the app which is foreground app when force stop
+        boolean fromForceStop = false;
+        if(reason != null && reason.startsWith("TPW-")){
+            fromForceStop = true;
+        }
+		boolean didSomething = killPackageProcessesLocked(name, appId, userId,
+                -100, callerWillRestart, (doRestartAfterForceStop(reason) && !fromForceStop), doit, evenPersistent,
+                name == null ? ((fromForceStop ? "TPW-stop user " : "stop user ") + userId) : ((fromForceStop ? "TPW-stop " : "stop ") + name));
 
         if (mStackSupervisor.forceStopPackageLocked(name, doit, evenPersistent, userId)) {
             if (!doit) {
@@ -7222,6 +7222,21 @@
             if (stack != null) {
                 ActivityRecord.activityResumedLocked(token);
             }
+            //FEATURE_STOP_APPS added by lixuhui 2015/03/06
+            ActivityRecord r = ActivityRecord.forToken(token);
+            String packageName = null;
+            String activityName = null;
+            if(r != null && r.realActivity != null) {
+                packageName = r.realActivity.getPackageName();
+                activityName = r.realActivity.getClassName();
+            }
+            if(AppChecker.FORCE_STOP_ENABLE){
+                if(r != null && mAppChecker != null){
+                    mAppChecker.putToPackageUsageRecords(packageName != null ? packageName : r.packageName,
+                            SystemClock.elapsedRealtime());
+                }
+            }
+            //FEATURE_STOP_APPS end
         }
         Binder.restoreCallingIdentity(origId);
     }
@@ -7234,6 +7249,14 @@
             if (stack != null) {
                 stack.activityPausedLocked(token, false);
             }
+        //FEATURE_STOP_APPS added by lixuhui 2015/03/06
+        ActivityRecord r = ActivityRecord.forToken(token);
+        if(AppChecker.FORCE_STOP_ENABLE){
+            if(r != null && mAppChecker != null){
+                mAppChecker.putToPackageUsageRecords(r.packageName, SystemClock.elapsedRealtime());
+            }
+        }
+        //FEATURE_STOP_APPS end
         }
         Binder.restoreCallingIdentity(origId);
     }
@@ -12327,6 +12350,18 @@
             mAppOpsService.systemReady();
             mSystemReady = true;
         }
+        //FEATURE_STOP_APPS added by lixuhui 2015/03/05 force stop some apps to prevent these apps to start after phone boot
+        if(mAppChecker.FORCE_STOP_ENABLE){
+            mAppChecker = new AppChecker(this, mCheckerService, mContext);
+            if(mAppChecker != null){
+                mAppChecker.startMonitorAlarm();
+                try {
+                  mAppChecker.forceStopApps();
+                }catch (RemoteException e){
+                }
+            }
+        }
+        //FEATURE_STOP_APPS end
 
         ArrayList<ProcessRecord> procsToKill = null;
         synchronized(mPidsSelfLocked) {
@@ -19780,6 +19995,77 @@
             }
         }
 
+        /// M: Set the service exceeded when memory critical @{ //no need
+        if (SystemProperties.get("ro.mtk_gmo_ram_optimize").equals("1")) {
+            int numTotalCached = 0;
+
+            // count the number of cache process(es)
+            for (int i = N - 1; i >= 0; i--) {
+                ProcessRecord app = mLruProcesses.get(i);
+                if (app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
+                    numTotalCached++;
+                }
+            }
+            // check if memory critical
+            if ((numTotalCached <= ProcessList.TRIM_CRITICAL_THRESHOLD)
+                    && (mLruProcesses.size() < mLastNumProcesses)
+                    && mAllowLowerMemLevel) {
+                // get memory status of cache process(es)
+                MemInfoReader memInfo = new MemInfoReader();
+                memInfo.readMemInfo();
+                long[] memInfos = memInfo.getRawInfo();
+
+                if (memInfos[Debug.MEMINFO_CACHED]
+                        <= mProcessList.getMemLevel(ProcessList.CACHED_APP_MIN_ADJ) / 1024) {
+                    int exceededApp = 0;
+                    int exceededService = 0;
+                    long lastActivity = 0;
+                    boolean lastActivityFound = false;
+                    if (DEBUG_OOM_ADJ) {
+                        Slog.d(TAG, "Memory Critical! Cached Size = "
+                                + memInfos[Debug.MEMINFO_CACHED] + " <= minfree [adj=9] = "
+                                + mProcessList.getMemLevel(ProcessList.CACHED_APP_MIN_ADJ));
+                    }
+                    // find the exceeded process (for 3rd party serviceb process only)
+                    for (int i = N - 1; i >= 0; i--) {
+                        ProcessRecord app = mLruProcesses.get(i);
+                        if ((app.serviceb) && !isSystemOrProtectedPackageName(app.processName)) {
+                            for (int is = app.services.size() - 1; is >= 0; is--) {
+                                ServiceRecord s = app.services.valueAt(is);
+                                if (DEBUG_OOM_ADJ) {
+                                    Slog.d(TAG, "Try to find exceededApp(" + i + ")="
+                                            + mLruProcesses.get(i) + ",exceededService("
+                                            + is + ")=" + mLruProcesses.get(i).services.valueAt(is)
+                                            + ",lastActivity="
+                                            + (now - s.lastActivity) / 1000.0 / 60.0
+                                            + " minute(s) ago. App lastPss size = "
+                                            + mLruProcesses.get(i).lastPss);
+                                }
+                                if ((now - s.lastActivity < ActiveServices.MAX_SERVICE_INACTIVITY)
+                                        && (now - s.lastActivity > lastActivity)) {
+                                    exceededApp = i;
+                                    exceededService = is;
+                                    lastActivity = now - s.lastActivity;
+                                    lastActivityFound = true;
+                                }
+                            }
+                        }
+                    }
+                    // Set an exceedService if found
+                    if (lastActivityFound) {
+                        Slog.d(TAG, "Set the exceededService! app = "
+                                + mLruProcesses.get(exceededApp) + ",service = "
+                                + mLruProcesses.get(exceededApp).services.valueAt(exceededService)
+                                + ",lastActivity=" + lastActivity / 1000.0 / 60.0
+                                + " minute(s) ago.");
+                        mLruProcesses.get(exceededApp).services.valueAt(exceededService)
+                                .lastActivity = now - ActiveServices.MAX_SERVICE_INACTIVITY;
+                    }
+                }
+            }
+        }
+        /// @}
+
         mNumServiceProcs = mNewNumServiceProcs;
 
         // Now determine the memory trimming level of background processes.
@@ -22190,5 +22476,26 @@
     public MultiWindowProxy mMultiWindowProxy;
     MwActivityMonitor mMwActivityMonitor;       /// Monitor the activity 
     /// @}
+
+    /// M: Default System or Protected PackageName List @{ //no need
+    private boolean isSystemOrProtectedPackageName(String name) {
+        final boolean isSystemOrProtected = name.matches("com\\.android\\..*") ||
+                                            name.matches("com\\.mediatek\\..*");
+        return isSystemOrProtected;
+    }
+    /// @}
+
     /// M: mediatek added functions end
+	AppChecker mAppChecker;
+    AppCheckerService mCheckerService;
+    public void setCheckerService(AppCheckerService service){
+      mCheckerService = service;
+    }
+
+    public interface BaseKeyguardChangeListener extends WindowManagerService.KeyguardChangeListener {
+    }
+
+    public void registeKeyguardChangeListener(BaseKeyguardChangeListener listener){
+        mWindowManager.registerKeyguardChangedListener(listener);
+    }
 }
Index: frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java	(revision 5734)
@@ -5947,6 +5947,13 @@
             throw new IllegalArgumentException("token == null");
         }
 
+        //added by lixuhui 2015/03/05
+        //FEATURE_STOP_APPS
+        for(KeyguardChangeListener listener : keyguradChangeListenerList){
+            listener.enableKeyguard(Binder.getCallingPid(), Binder.getCallingUid(), false);
+        }
+        //add end
+
         mKeyguardDisableHandler.sendMessage(mKeyguardDisableHandler.obtainMessage(
                 KeyguardDisableHandler.KEYGUARD_DISABLE, new Pair<IBinder, String>(token, tag)));
     }
@@ -5962,6 +5969,13 @@
             throw new IllegalArgumentException("token == null");
         }
 
+        //added by lixuhui 2015/03/05
+        //FEATURE_STOP_APPS
+        for(KeyguardChangeListener listener : keyguradChangeListenerList){
+            listener.enableKeyguard(Binder.getCallingPid(), Binder.getCallingUid(), true);
+        }
+        //add end
+
         mKeyguardDisableHandler.sendMessage(mKeyguardDisableHandler.obtainMessage(
                 KeyguardDisableHandler.KEYGUARD_REENABLE, token));
     }
@@ -13800,4 +13814,19 @@
         return enableRecentAppsKey;
     } 
     //end
+	
+    //added by lixuhui 2015/03/05
+    //FEATURE_STOP_APPS
+    private List<KeyguardChangeListener> keyguradChangeListenerList = new ArrayList<KeyguardChangeListener>();
+
+    public void registerKeyguardChangedListener(KeyguardChangeListener listener){
+        if(!keyguradChangeListenerList.contains(listener)){
+            keyguradChangeListenerList.add(listener);
+        }
+    }
+
+    public interface KeyguardChangeListener{
+        public void enableKeyguard(int pid, int uid, boolean enable);
+    }
+    //added end
 }
Index: frameworks/base/services/core/java/com/android/server/job/JobSchedulerService.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/job/JobSchedulerService.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/job/JobSchedulerService.java	(revision 5734)
@@ -814,6 +814,18 @@
             }
         }
 
+        //added by lixuhui 2016/01/22 cancel the jobs about uid
+        @Override
+        public void cancelJobsForUid(int uid) throws RemoteException {
+            long ident = Binder.clearCallingIdentity();
+            try {
+                JobSchedulerService.this.cancelJobsForUid(uid);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        //end
+
         /**
          * "dumpsys" infrastructure
          */
Index: frameworks/base/services/core/java/com/android/server/pm/PackageSettingBase.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/pm/PackageSettingBase.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/pm/PackageSettingBase.java	(revision 5734)
@@ -312,6 +312,16 @@
         modifyUserState(userId).stopped = stop;
     }
 
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    boolean getKilled(int userId){
+        return readUserState(userId).killed;
+    }
+
+    void setKilled(boolean killed, int userId){
+        modifyUserState(userId).killed = killed;
+    }
+    //end
+
     boolean getNotLaunched(int userId) {
         return readUserState(userId).notLaunched;
     }
Index: frameworks/base/services/core/java/com/android/server/pm/Settings.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/pm/Settings.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/pm/Settings.java	(revision 5734)
@@ -3327,6 +3327,12 @@
                 Slog.i(TAG, "Stopping package " + packageName, e);
             }
         }
+        //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+        //we must reset the killed property to false when we start the application
+        if(!stopped && pkgSetting.getKilled(userId)){
+            pkgSetting.setKilled(false, userId);
+        }
+        //end
         if (pkgSetting.getStopped(userId) != stopped) {
             pkgSetting.setStopped(stopped, userId);
             // pkgSetting.pkg.mSetStopped = stopped;
@@ -3343,6 +3349,46 @@
         return false;
     }
 
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    /*
+     * setting the package state to killed
+     * */
+    boolean setPackageKilledStateLPw(PackageManagerService yucky, String packageName, boolean killed,
+            boolean allowedByPermission, int uid, int userId) {
+        int appId = UserHandle.getAppId(uid);
+        final PackageSetting pkgSetting = mPackages.get(packageName);
+        if (pkgSetting == null) {
+            throw new IllegalArgumentException("Unknown package: " + packageName);
+        }
+        if (!allowedByPermission && (appId != pkgSetting.appId)) {
+            throw new SecurityException(
+                    "Permission Denial: attempt to change stopped state from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + uid + ", package uid=" + pkgSetting.appId);
+        }
+        if (DEBUG_STOPPED) {
+            if (killed) {
+                RuntimeException e = new RuntimeException("here");
+                e.fillInStackTrace();
+                Slog.i(TAG, "Stopping package " + packageName, e);
+            }
+        }
+        if (pkgSetting.getKilled(userId) != killed) {
+            pkgSetting.setKilled(killed, userId);
+            // pkgSetting.pkg.mSetStopped = stopped;
+            if (pkgSetting.getNotLaunched(userId)) {
+                if (pkgSetting.installerPackageName != null) {
+                    yucky.sendPackageBroadcast(Intent.ACTION_PACKAGE_FIRST_LAUNCH,
+                            pkgSetting.name, null,
+                            pkgSetting.installerPackageName, null, new int[] {userId});
+                }
+                pkgSetting.setNotLaunched(false, userId);
+            }
+            return true;
+        }
+        return false;
+    }
+    //end
     private List<UserInfo> getAllUsers() {
         long id = Binder.clearCallingIdentity();
         try {
Index: frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
===================================================================
--- frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java	(revision 5726)
+++ frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java	(revision 5734)
@@ -226,6 +226,9 @@
 
 import com.mediatek.archHelper.ArchHelper;
 
+import com.topwise.appcheck.IAppChecker;
+import com.topwise.appcheck.AppCheckerInfo;
+
 /**
  * Keep track of all those .apks everywhere.
  *
@@ -7671,6 +7674,7 @@
         return allowed;
     }
 
+    private static IAppChecker sChecker = null;
     final class ActivityIntentResolver
             extends IntentResolver<PackageParser.ActivityIntentInfo, ResolveInfo> {
         public List<ResolveInfo> queryIntent(Intent intent, String resolvedType,
@@ -8040,13 +8044,32 @@
                     // System apps are never considered stopped for purposes of
                     // filtering, because there may be no way for the user to
                     // actually re-launch them.
-                    return (ps.pkgFlags&ApplicationInfo.FLAG_SYSTEM) == 0
-                            && ps.getStopped(userId);
+                    return ((ps.pkgFlags&ApplicationInfo.FLAG_SYSTEM) == 0
+                            || inBlacklist(p.packageName)) //FEATURE_STOP_APPS added by lixuhui 2015/03/05 force stop some apps to prevent these apps to start after phone boot
+                            && (ps.getStopped(userId) || ps.getKilled(userId));  //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
                 }
             }
             return false;
         }
 
+        private boolean inBlacklist(String packageName){
+            if (sChecker == null){
+                IBinder binder = ServiceManager.getService("appchecker");
+                sChecker = IAppChecker.Stub.asInterface(binder);
+            }
+            try{
+                List<AppCheckerInfo> blackList = sChecker.getSysBlackList();
+                for (AppCheckerInfo info : blackList){
+                    if (info.packageName.equals(packageName)){
+                        return true;
+                    }
+                }
+            }catch(RemoteException e){
+                return false;
+            }
+            return false;
+        }
+
         @Override
         protected boolean isPackageForFilter(String packageName,
                 PackageParser.ActivityIntentInfo info) {
@@ -13149,6 +13172,30 @@
         }
     }
 
+    //FEATURE_STOP_APPS modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    /**
+     * add this method to kill the application but not change the status to stopped, so you can see the application status is not stopped in settings application
+     * @param packageName
+     * @param killed
+     * @param userId
+     */
+    public void setPackageKilledState(String packageName, boolean killed, int userId) {
+        if (!sUserManager.exists(userId)) return;
+        final int uid = Binder.getCallingUid();
+        final int permission = mContext.checkCallingOrSelfPermission(
+                android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
+        final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
+        enforceCrossUserPermission(uid, userId, true, false, "stop package");
+        // writer
+        synchronized (mPackages) {
+            if (mSettings.setPackageKilledStateLPw(this, packageName, killed, allowedByPermission,
+                    uid, userId)) {
+                scheduleWritePackageRestrictionsLocked(userId);
+            }
+        }
+    }
+    //end
+
     @Override
     public String getInstallerPackageName(String packageName) {
         // reader
Index: frameworks/base/services/core/java/com/topwise/appchecker/AppChecker.java
===================================================================
--- frameworks/base/services/core/java/com/topwise/appchecker/AppChecker.java	(revision 0)
+++ frameworks/base/services/core/java/com/topwise/appchecker/AppChecker.java	(revision 5734)
@@ -0,0 +1,900 @@
+package com.android.server.am;
+
+import android.app.AlarmManager;
+import android.app.AppGlobals;
+import android.app.PendingIntent;
+import android.app.WallpaperInfo;
+import android.app.WallpaperManager;
+import android.app.job.JobScheduler;
+import android.appwidget.AppWidgetProviderInfo;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.content.pm.ParceledListSlice;
+import android.content.pm.ResolveInfo;
+import android.media.AudioManager;
+import android.os.Binder;
+//import android.os.BlacklistHelper;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.Process;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Slog;
+import com.android.internal.os.ProcessCpuTracker;
+import com.android.internal.appwidget.IAppWidgetService; 
+import android.text.TextUtils.SimpleStringSplitter;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.HashSet;
+
+import com.topwise.appcheck.IAppChecker;
+import com.topwise.appchecker.AppCheckerService;
+import com.topwise.appchecker.AppCheckerService.LevelTimeChangedListener;
+import com.topwise.appcheck.AppCheckerManager;
+import com.topwise.appcheck.AppCheckerInfo;
+import android.os.RemoteException;
+import android.os.IBinder;
+
+public class AppChecker implements LevelTimeChangedListener{
+    
+    private static final String TAG = "AppChecker";
+    
+    private ActivityManagerService mService;
+    private AppCheckerService mAppCheckerService;
+    private Context mContext;
+    private String mCurrentKeyguardPackage = null;
+    private String mAliKeyguardPackage = null;
+
+    //FEATURE_STOP_APPS added by lixuhui 2015/03/06 for kill the app which not luanch in 24 hours
+    static boolean DEBUG_NOT_LAUNCH_CHECK = true;
+    static final boolean FORCE_STOP_ENABLE = SystemProperties.getBoolean("persist.force_stop_enable", true);
+    private static final String ALARM_CHECK_BROADCAST_ACTION = "com.tpwise.check_not_launch_action";
+    //in the white list apps(we Attentive apps, like the IM apps) can keep live times, default 24 hours
+    static final int KILL_APP_TIME_SLONG_THRESHOLD = SystemProperties.getInt("persist.high_level_time", 24 * 60);
+    //default 2 minute/1 hour to check interval
+    static final int CHECK_INTERVAL_TIME = SystemProperties.getInt("persist.not_launch_check_time", isSmartDetectedEnable() ? 3 : 60);
+    // long level apps(map apps) can keep live times, default 3 hours
+    private static final int LONG_LEVEL_TIME_THRESHOLD  = SystemProperties.getInt("persist.medium_level_time", 3 * 60);
+    // medium level apps(browser,news reader app etc) can keep live times, default 1 hours
+    private static final int MEDIUM_LEVEL_TIME_THRESHOLD  = SystemProperties.getInt("persist.low_level_time", 60);
+    // low level apps, default 15 min
+    private static final int LOW_LEVEL_TIME_THRESHOLD  = SystemProperties.getInt("persist.low_level_time", 15); 
+    
+    // default 25 minute
+    static final int SMART_DETECT_TIME_THRESHOLD = SystemProperties.getInt("persist.smart_detect_time", isSmartDetectedEnable() ? 10 : KILL_APP_TIME_SLONG_THRESHOLD);
+    private static final int TIME_MINUTE_UNIT = 60 * 1000;  //1 minute
+    private static final int VERIFY_TIMES = isSmartDetectedEnable() ? (Math.min((SMART_DETECT_TIME_THRESHOLD / CHECK_INTERVAL_TIME) * 2 + 1, 3)) : 0;
+    private IAppWidgetService mAppWidgetService; //L version
+    private Map<String, Long>  mPackageUsageRecords = new HashMap<String, Long>();
+    
+    private Map<String, VerifyApp> needVerifyList = new HashMap<String, VerifyApp>();
+    
+    final static SimpleStringSplitter mStringColonSplitter = new SimpleStringSplitter(':');
+
+    //level time
+    private int mSuperLongThreshold = 0;
+    private int mLongThreshold = 0;
+    private int mMediumThreshold = 0;
+    private int mShortThreshold = 0;
+    
+    public AppChecker(ActivityManagerService activityManagerService, AppCheckerService checkerService, Context context){
+        mService = activityManagerService;
+        mContext = context;
+        mAppCheckerService = checkerService;
+        Log.d(TAG, "appchecker started, AppCheckerManager: " + mAppCheckerService);
+        initThreshold();
+        mAppCheckerService.registerLevelTimeChangedListener(this);
+    }
+
+    private void initThreshold(){
+        if (mAppCheckerService != null){
+            mSuperLongThreshold = mAppCheckerService.getLevelTime(AppCheckerManager.SUPERLONG_LEVEL);
+            mLongThreshold = mAppCheckerService.getLevelTime(AppCheckerManager.LONG_LEVEL);
+            mMediumThreshold = mAppCheckerService.getLevelTime(AppCheckerManager.MEDIUM_LEVEL);
+            mShortThreshold = mAppCheckerService.getLevelTime(AppCheckerManager.SHORT_LEVEL);
+        }
+        mSuperLongThreshold = mSuperLongThreshold > 0 ? mSuperLongThreshold : KILL_APP_TIME_SLONG_THRESHOLD;
+        mLongThreshold = mLongThreshold > 0 ? mLongThreshold : LONG_LEVEL_TIME_THRESHOLD;
+        mMediumThreshold = mMediumThreshold > 0 ? mMediumThreshold : MEDIUM_LEVEL_TIME_THRESHOLD;
+        mShortThreshold = mShortThreshold > 0 ? mShortThreshold : LOW_LEVEL_TIME_THRESHOLD;
+    }
+
+    public static boolean isSmartDetectedEnable(){
+        return "1".equals(SystemProperties.get("persist.smart_detect_enable","1"));
+    }
+    
+    void putToPackageUsageRecords(String packageName, long time){
+        mPackageUsageRecords.put(packageName, time);
+    }
+    
+    /**
+     * force stop system app in blacklist and all install app by user when boot phone
+     */
+    void forceStopApps() throws RemoteException{
+        try{
+            Set<String> enableAccessibilitys = getEnableAccessibilityPackage();
+            /*String[] blacklist = BlacklistHelper.getBlackList();*/
+            List<AppCheckerInfo> blacklist = mAppCheckerService.getForceStopList();
+            for(AppCheckerInfo info : blacklist){
+                String packageName = info.packageName;
+                Slog.d(TAG, "force stop process:" + packageName);
+                //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+//                forceStopPackage(packageName, UserHandle.myUserId());
+                if(isEnableAccessibilityPackage(packageName, enableAccessibilitys)){
+                    continue;
+                }
+                /**
+                if(isLockedAppBySystemUi(packageName)) {
+                    continue;
+                }
+                */
+                forceKillUnusePackage(packageName, UserHandle.myUserId(), false);
+                //end
+            }
+            //forceStopDataApps(enableAccessibilitys);
+        }catch(Exception e){
+            Slog.d(TAG, "force stop--" + e.getMessage());
+            e.printStackTrace();
+        }
+    }
+    
+    /**
+     * force stop all install app by user when boot phone
+     */
+    @SuppressWarnings("unchecked")
+    private void forceStopDataApps (Set<String> enableAccessibilitys) throws RemoteException{
+        IPackageManager pm = AppGlobals.getPackageManager();
+        try {
+            ParceledListSlice<ApplicationInfo> appList = pm.getInstalledApplications(0, UserHandle.myUserId());
+            List<ApplicationInfo> applicationList = appList.getList();
+            String defaultIME = Settings.Secure.getString(mContext.getContentResolver(),
+                    Settings.Secure.DEFAULT_INPUT_METHOD);
+           
+            WallpaperManager mWallpaperManager = (WallpaperManager) mContext
+                    .getSystemService(Context.WALLPAPER_SERVICE);
+            WallpaperInfo wallpaperInfo = mWallpaperManager.getWallpaperInfo();
+            //Android L version interface
+            String wallpaperComponent = Settings.System.getString(mContext.getContentResolver(), Settings.System.CURRENT_WALLPAPER_NAME);
+            if(wallpaperComponent != null){
+                wallpaperComponent = wallpaperComponent.substring(0,wallpaperComponent.lastIndexOf("&"));
+            }
+            slogd("force stop  wallpaperComponent=" + wallpaperComponent);
+
+            for(ApplicationInfo applicationInfo : applicationList){
+                if((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0 
+                        && (applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) == 0 
+                        && (applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) == 0
+                        && !applicationInfo.killed
+                        && !isInAppList(mAppCheckerService.getExcludeList(), applicationInfo.packageName)/*!BlacklistHelper.isInExcludeList(applicationInfo.packageName)*/){
+//                    Slog.d(TAG, "force stop data app:" + applicationInfo.packageName);
+                    //maybe this not use any more
+                    ArrayList<ResolveInfo> homeActivities = new ArrayList<ResolveInfo>();
+                    ComponentName currentDefaultHome  = mContext.getPackageManager().getHomeActivities(homeActivities);
+                    //no need to force stop the default launcher
+                    if(currentDefaultHome != null && applicationInfo.packageName.equals(currentDefaultHome.getPackageName())){
+                        continue;
+                    }
+                    //can not force close the default third part inputmethod, if force close this package,it will set the system default inputmethod as current default inputmethod  
+                    if(defaultIME != null && applicationInfo.packageName.equals(defaultIME.substring(0, defaultIME.indexOf("/")))){
+                        Slog.d(TAG, "force stop data app not include current inputmethod--" + applicationInfo.packageName);
+                        continue;
+                    }
+                    //do not force close the third part dynamic wallpaper, it will cause the dynamic disable and set to default static wallpaper
+//                    if(wallpaperInfo != null && applicationInfo.packageName.equals(wallpaperInfo.getPackageName())){  //Android KK version interface
+                    if(applicationInfo.packageName.equals(wallpaperComponent)){   //Android L version interface
+                        Slog.d(TAG, "force stop data app not include current dynamic wallpaper--" + applicationInfo.packageName);
+                        continue;
+                    }
+                    
+                    //remove the 3rd lock screen app
+                    mCurrentKeyguardPackage = Settings.System.getString(mContext.getContentResolver(), "keyguard_package");
+                    mAliKeyguardPackage = Settings.Secure.getString(mContext.getContentResolver(), "3rd_party_lockscreen");
+                    if(applicationInfo.packageName.equals(mCurrentKeyguardPackage) || applicationInfo.packageName.equals(mAliKeyguardPackage)){
+                        Slog.d(TAG, "force stop---remove the 3rd lock screen app--" + mCurrentKeyguardPackage + ",,mAliKeyguardPackage=" + mAliKeyguardPackage);
+                        continue;
+                    }
+                    
+                    //remove the enable accessibility app
+                    if(isEnableAccessibilityPackage(applicationInfo.packageName, enableAccessibilitys)){
+                        Slog.d(TAG, "force stop---remove the enable accessibility app--" + applicationInfo.packageName);
+                        continue;
+                    }
+
+                    //remove the locked app by systemui app
+                    /**
+                    if(isLockedAppBySystemUi(applicationInfo.packageName)) {
+                        Slog.d(TAG, "force stop---remove the locked app by systemui--" + applicationInfo.packageName);
+                        continue;
+                    }
+                    */
+                    
+                    //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+//                    forceStopPackage(applicationInfo.packageName, UserHandle.myUserId());
+                    forceKillUnusePackage(applicationInfo.packageName, UserHandle.myUserId(), false);
+                    //end
+                }
+            }
+        }catch(RemoteException e){
+            e.printStackTrace();
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    private Set<String> getForceStopAppList() throws RemoteException{
+        Set<String> forceStopAppList = new HashSet<String>();
+        //add the system app in black list to force stop list
+        //String[] blacklist = BlacklistHelper.getBlackList();
+        List<AppCheckerInfo> blacklist = mAppCheckerService.getSysBlackList();
+        IPackageManager pm = AppGlobals.getPackageManager();
+        for(AppCheckerInfo info : blacklist){
+            String blackItem = info.packageName;
+            if(!isApplicationStopped(pm, blackItem)){
+                forceStopAppList.add(blackItem);
+            }
+        }
+        //add the system app only runtime list to force stop
+       /* String[] runtimeList = BlacklistHelper.getOnlyRuntimeList();
+        for(String runtimeItem : runtimeList){
+            if(!isApplicationStopped(pm, runtimeItem)){
+                forceStopAppList.add(runtimeItem);
+            }
+        }*/
+        //add the third part app to force stop list
+        try {
+            ParceledListSlice<ApplicationInfo> appList = pm.getInstalledApplications(0, UserHandle.myUserId());
+            List<ApplicationInfo> applicationList = appList.getList();
+            for(ApplicationInfo applicationInfo : applicationList){
+                if((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0 
+                        && (applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) == 0
+                        && (applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) == 0 
+                        && !applicationInfo.killed 
+                        && !isInAppList(mAppCheckerService.getExcludeList(), applicationInfo.packageName)
+                        && !isInLevelList(AppCheckerManager.NO_CHECK_LEVEL, applicationInfo.packageName)/*!BlacklistHelper.isInExcludeList(applicationInfo.packageName)*/){ //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+                    forceStopAppList.add(applicationInfo.packageName);
+                }
+            }
+        }catch(RemoteException e){
+            e.printStackTrace();
+        }
+        
+        slogd("force stop--original--froceStopAppList=" + forceStopAppList);
+        
+        //remove the home process from force stop list
+        if(mService.mHomeProcess != null){
+            if(forceStopAppList.contains(mService.mHomeProcess.info.packageName)){
+                forceStopAppList.remove(mService.mHomeProcess.info.packageName);
+            }
+        }
+
+        //can not force close the default third part inputmethod, if force close this package,it will set the system default inputmethod as current default inputmethod  
+        String defaultIME = Settings.Secure.getString(mContext.getContentResolver(),
+                Settings.Secure.DEFAULT_INPUT_METHOD);
+        String imePacakgeName = defaultIME.substring(0, defaultIME.indexOf("/"));
+        if(defaultIME != null && forceStopAppList.contains(imePacakgeName)){
+            Slog.d(TAG,"--remove current inputmethod from force stop list:" + imePacakgeName);
+            forceStopAppList.remove(imePacakgeName);
+        }
+
+        //do not force close the third part dynamic wallpaper, it will cause the dynamic disable and set to default static wallpaper
+        WallpaperManager mWallpaperManager = (WallpaperManager) mContext
+                .getSystemService(Context.WALLPAPER_SERVICE);
+        WallpaperInfo wallpaperInfo = mWallpaperManager.getWallpaperInfo();
+        if(wallpaperInfo != null && forceStopAppList.contains(wallpaperInfo.getPackageName())){
+            Slog.d(TAG,"--remove dynamic wallpaper from force stop list:" + wallpaperInfo.getPackageName());
+            forceStopAppList.remove(wallpaperInfo.getPackageName());
+        }
+        
+        //do not kill the current media process
+        AudioManager mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
+        String aduioFocusPackage = mAudioManager.getCurrentAudioFocusPackageName();
+        boolean isInCall = mAudioManager.isInCall();
+        slogd("force stop--isMusicActive--" + mAudioManager.isMusicActive() /*+ ",,isFmActive=" + mAudioManager.isFmActive() */+ ",,isAudioFocusExclusive=" + mAudioManager.isAudioFocusExclusive() + ",,isInCall=" + isInCall + ",,aduioFocusPackage=" + aduioFocusPackage);
+        if(aduioFocusPackage != null){
+            if(isInCall){
+                checkAudioApp(aduioFocusPackage, true);
+                forceStopAppList.remove(aduioFocusPackage);
+            }else{
+                if(mAudioManager.isMusicActive() /*|| mAudioManager.isFmActive()*/){
+                    if(needVerifyList.containsKey(aduioFocusPackage)){
+                        needVerifyList.remove(aduioFocusPackage);
+                    }
+                    forceStopAppList.remove(aduioFocusPackage);
+                }else{
+                    if(checkAudioApp(aduioFocusPackage, false)){
+                        forceStopAppList.remove(aduioFocusPackage);
+                    }
+                }
+            }
+        }
+        
+        //remove the current display process from force stop list
+        ActivityStack focusStack = mService.mStackSupervisor.getFocusedStack();
+        mAliKeyguardPackage = Settings.Secure.getString(mContext.getContentResolver(), "3rd_party_lockscreen");
+        if(focusStack.getStackId() != ActivityStackSupervisor.HOME_STACK_ID){
+            int size = focusStack.getAllTasks().size();
+            if(size > 0){
+                List<ActivityRecord> topTaskActivities = focusStack.getAllTasks().get(size - 1).mActivities;
+                boolean isLockScreenAppFront = false;
+                boolean isCallUiFront = false;   //the call ui is in front
+                for(ActivityRecord activityRecord : topTaskActivities){
+                    //mark the top task is dialer app or not. we will not kill the second the task when in calling
+                    if("com.android.dialer".equals(activityRecord.packageName)){
+                        isCallUiFront = true;
+                    }
+                    if(forceStopAppList.contains(activityRecord.packageName)){
+                        slogd("--remove from force stop list:" + activityRecord.packageName + "--mCurrentKeyguardPackage=" + mCurrentKeyguardPackage);
+                        forceStopAppList.remove(activityRecord.packageName);
+                        if((mCurrentKeyguardPackage != null && activityRecord.packageName.equals(mCurrentKeyguardPackage))
+                                || (mAliKeyguardPackage != null && activityRecord.packageName.equals(mAliKeyguardPackage))){
+                            isLockScreenAppFront = true;
+                        }
+                    }
+                }
+                slogd("force stop---isLockScreenAppFront=" + isLockScreenAppFront + ",,isCallUiFront=" + isCallUiFront + ",,isInCall=" + isInCall);
+                if((isLockScreenAppFront || (isCallUiFront && isInCall)) && size > 1){
+                    List<ActivityRecord> secondTaskActivities = focusStack.getAllTasks().get(size - 2).mActivities;
+                    for(ActivityRecord activityRecord : secondTaskActivities){
+                        if(activityRecord.nowVisible && forceStopAppList.contains(activityRecord.packageName)){
+                            slogd("3rd lock screen app--remove from force stop list:" + activityRecord.packageName);
+                            forceStopAppList.remove(activityRecord.packageName);
+                        }
+                    }
+                }
+            }
+        }
+
+        if(mCurrentKeyguardPackage != null && forceStopAppList.contains(mCurrentKeyguardPackage)){
+            slogd("--remove current 3rd lock screen app from force stop list:" + mCurrentKeyguardPackage);
+            forceStopAppList.remove(mCurrentKeyguardPackage);
+        }
+        //only for ali 3rd lock screen
+        if(mAliKeyguardPackage != null && forceStopAppList.contains(mAliKeyguardPackage)){
+            slogd("--remove current 3rd lock screen app from force stop list:" + mAliKeyguardPackage);
+            forceStopAppList.remove(mAliKeyguardPackage);
+        }
+
+        //remove the current AppWidgetHost from force stop list
+        if(mAppWidgetService != null){
+            List<AppWidgetProviderInfo> enabledAppWidgetList = null; //android L version 
+            //ArrayList<AppWidgetServiceImpl.AppWidgetId> enabledAppWidgetList = null;  //android KK version
+            //TODO maybe execute this codes in future for not include the widgets only attach to current launcher
+            /**
+            if(mHomeProcess != null){
+                String homePackageName = mHomeProcess.info.packageName;
+                slogd("force stop--current laucher app widget---");
+                ArrayList<AppWidgetServiceImpl.Host> appWidgetHosts = mAppWidgetService.getAppWidgetHostList(mContext.getUserId());
+                for(AppWidgetServiceImpl.Host host : appWidgetHosts){
+                    if(homePackageName.equals(host.packageName)){
+                        enabledAppWidgetList = host.instances;
+                        break;
+                    }
+                }
+            }
+            */
+            if(enabledAppWidgetList == null){
+                slogd("force stop--all app widget---");
+                try{
+                    enabledAppWidgetList = mAppWidgetService.getEnableWidgetProviderInfos();  // Android L version interface
+                    //enabledAppWidgetList = mService.mAppWidgetService.getEnabledAppWidgetList(mContext.getUserId());    // Android KK version interface
+                }catch(Exception e){
+                }
+            }
+
+            if(enabledAppWidgetList != null){
+                //Android L version interface
+                for(AppWidgetProviderInfo appWidgetInfo : enabledAppWidgetList){
+                    if(appWidgetInfo != null){
+                        try{
+                            Slog.d(TAG, "remove enabled widget from force stop list:" + appWidgetInfo.provider.getPackageName());
+                            forceStopAppList.remove(appWidgetInfo.provider.getPackageName());
+                        }catch(NullPointerException e){
+                            e.printStackTrace();
+                        }
+                    }
+                }
+                // Android KK version interface
+                /**
+                for(AppWidgetServiceImpl.AppWidgetId appWidgetId : enabledAppWidgetList){
+                    if(appWidgetId != null && appWidgetId.provider != null){
+                        try{
+                            Slog.d(TAG, "remove enabled widget from force stop list:" + appWidgetId.provider.info.provider.getPackageName());
+                            forceStopAppList.remove(appWidgetId.provider.info.provider.getPackageName());
+                        }catch(NullPointerException e){
+                            e.printStackTrace();
+                        }
+                    }
+                }
+                */
+            }
+
+        }
+        //remove the enable accessibility apps
+        removeEnableAccessibilityPackage(forceStopAppList);
+
+        return forceStopAppList;
+    }
+    
+    private Set<String> getEnableAccessibilityPackage(){
+        final String enabledServicesSetting = Settings.Secure.getString(
+                mContext.getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
+        if (enabledServicesSetting == null) {
+            return Collections.emptySet();
+        }
+        Set<String> accessibilityPackages = new HashSet<String>();
+        mStringColonSplitter.setString(enabledServicesSetting);
+
+        while (mStringColonSplitter.hasNext()) {
+            final String componentNameString = mStringColonSplitter.next();
+            final ComponentName enabledService = ComponentName.unflattenFromString(
+                    componentNameString);
+            if (enabledService != null) {
+                accessibilityPackages.add(enabledService.getPackageName());
+            }
+        }
+        
+        return accessibilityPackages;
+    }
+    
+    private boolean isEnableAccessibilityPackage(String packageName, Set<String> enableAccessibilitys){
+        if(enableAccessibilitys == null) return false;
+        if(enableAccessibilitys.contains(packageName)){
+            return true;
+        }
+        return false;
+    }
+    
+    /**
+     * remvoe the enable accessibility package, it will make the function disable
+     */
+    private void removeEnableAccessibilityPackage(Set<String> forceStopAppList) {
+        final String enabledServicesSetting = Settings.Secure.getString(
+                mContext.getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
+        if (enabledServicesSetting == null) {
+            slogd("force stop---enabledServicesSetting is null---");
+            return ;
+        }
+
+        mStringColonSplitter.setString(enabledServicesSetting);
+
+        while (mStringColonSplitter.hasNext()) {
+            final String componentNameString = mStringColonSplitter.next();
+            final ComponentName enabledService = ComponentName.unflattenFromString(
+                    componentNameString);
+            if (enabledService != null) {
+                if(forceStopAppList.contains(enabledService.getPackageName())){
+                    forceStopAppList.remove(enabledService.getPackageName());
+                    slogd("force stop--remove the enable accessibility package:" + enabledService.getPackageName());
+                }
+            }
+        }
+    }
+    
+    private boolean checkAudioApp(String packageName, boolean isInCall){
+        VerifyApp verifyApp = needVerifyList.get(packageName);
+        if(verifyApp != null && packageName.equals(verifyApp.getPackageName())){
+            slogd("force stop--it already in the verify list:" + packageName + ",,isInCall:" + isInCall);
+            int restTimes = verifyApp.getRestTimes();
+            if (restTimes == 0) {
+                slogd("force stop--verify complete, decide to kill the audio package:"
+                        + packageName + ",,isInCall=" + isInCall);
+                if (!isInCall) {
+                    needVerifyList.remove(packageName);
+                }
+                return false;
+            } else {
+                --restTimes;
+                verifyApp.setRestTimes(restTimes);
+                slogd("force stop--verify the audio package:" + packageName
+                        + ",restTimes=" + restTimes + ",,isInCall=" + isInCall);
+                // forceStopAppList.remove(packageName);
+                return true;
+            }
+        }else if(!isInCall){
+            slogd("force stop--add the current audio focus package to verify list:" + packageName + ",,isInCall=" + isInCall);
+            needVerifyList.put(packageName, new VerifyApp(packageName));
+            return true;
+        }
+        slogd("force stop-- the current audio focus package not in the verify list:"
+                + packageName + ",,isInCall=" + isInCall);
+        return true;
+    }
+    
+    /**
+     * define this class to record the focus audio app check times
+     * it has this condition: when we listen a music in background, and then there is a call coming, we receive it.
+     * when we end the call, the system will switch to play the music continue, but switch from call to music there will
+     * spend a little time. so the music app maybe killed by this function in this time. For fix the potential bug, we add
+     * the restTimes to void this.
+     */
+    private static class VerifyApp{
+        String packageName;
+        int restTimes = VERIFY_TIMES;
+
+        public VerifyApp(String packageName){
+            this.packageName = packageName;
+        }
+
+        public String getPackageName(){
+            return this.packageName;
+        }
+
+        public int getRestTimes(){
+            return this.restTimes;
+        }
+
+        public void setRestTimes(int restTimes){
+            this.restTimes = restTimes;
+        }
+    }
+    
+    /**
+     * listene the keyguard enable/disable change event
+     * 
+     */
+    public class AppCheckerKeyguardChangeListener implements ActivityManagerService.BaseKeyguardChangeListener {
+        @Override
+        public void enableKeyguard(int pid, int uid, boolean enable){
+            boolean needUpdate = true;
+            try{
+                String packageName = AppGlobals.getPackageManager().getNameForUid(uid);
+                slogd("----enableKeyguard--force stop---packageName=" + packageName + "--enable=" + enable);
+                if(packageName != null && packageName.equals(mCurrentKeyguardPackage) && !enable){
+                    needUpdate = false;
+                    return;
+                }
+                if(!enable){
+                    mCurrentKeyguardPackage = packageName;
+                }else{
+                    mCurrentKeyguardPackage = null;
+                }
+            }catch(RemoteException e){
+                if(enable){
+                    mCurrentKeyguardPackage = null;
+                }
+            }finally{
+                if(needUpdate){
+                    long origId = Binder.clearCallingIdentity();
+                    try{
+                        Settings.System.putString(mContext.getContentResolver(), "keyguard_package", mCurrentKeyguardPackage);
+                    }finally{
+                        Binder.restoreCallingIdentity(origId);
+                    }
+                }
+            }
+        }
+    }
+
+    void putPackageUsageRecords(String key, Long value){
+        mPackageUsageRecords.put(key, value);
+    }
+
+    void startMonitorAlarm(){
+        slogd("----startMonitorAlarm--force stop---");
+        
+        AppCheckerKeyguardChangeListener keyguardListener = new AppCheckerKeyguardChangeListener();
+        mService.registeKeyguardChangeListener(keyguardListener);
+        
+        MonitorAppUseReceiver mMonitorAppUserReceiver = new MonitorAppUseReceiver();
+        IntentFilter filter = new IntentFilter(ALARM_CHECK_BROADCAST_ACTION);
+        mContext.registerReceiver(mMonitorAppUserReceiver, filter);
+        
+        mAppWidgetService = IAppWidgetService.Stub.asInterface(ServiceManager.getService(Context.APPWIDGET_SERVICE));
+        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+        Intent intent = new Intent(ALARM_CHECK_BROADCAST_ACTION);
+        PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        //alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT, CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT, pendingIntent);
+        if (isSmartDetectedEnable()) {
+            alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME,
+                    SystemClock.elapsedRealtime() + CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT,
+                    CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT,
+                    pendingIntent);
+        } else {
+            alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    SystemClock.elapsedRealtime() + CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT,
+                    CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT,
+                    pendingIntent);
+        }
+    }
+
+    void enableLog(boolean enable){
+        DEBUG_NOT_LAUNCH_CHECK = enable;
+        if(mAppCheckerService != null){
+            mAppCheckerService.enableLog(enable);
+        }
+    }
+    
+    class MonitorAppUseReceiver extends BroadcastReceiver{
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            slogd("MonitorAppUseReceiver--onReceive--force stop--");
+            try{
+                forceStopUnuseAppLongTime();
+            }catch(Exception e){
+                Slog.d(TAG, "force stop---" + e.getMessage());
+                e.printStackTrace();
+            }
+        }
+    }
+    
+    /*
+    private class MonitorAppUseThread extends Thread{
+        @Override
+        public void run() {
+            // TODO Auto-generated method stub
+            while(true){
+                synchronized (mMonitorAppUseThread) {
+                    try{
+                        wait(CHECK_INTERVAL_TIME * TIME_MINUTE_UNIT);
+                    }catch(InterruptedException e){}
+                }
+                try{
+                    forceStopUnuseAppLongTime();
+                }catch(Exception e){
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+    **/
+
+    private void forceStopUnuseAppLongTime() throws RemoteException{
+        Set<String> forceStopList = getForceStopAppList();
+        long currentTime = SystemClock.elapsedRealtime();
+        if(DEBUG_NOT_LAUNCH_CHECK){
+            Slog.d(TAG, "force stop candidate app list:" + forceStopList);
+            Slog.d(TAG, "force stop currentTime=" + currentTime);
+            Iterator<Map.Entry<String, Long>> iterator = mPackageUsageRecords.entrySet().iterator();
+            while(iterator.hasNext()){
+                Map.Entry<String, Long> entry = iterator.next();
+                Slog.d(TAG, "force stop: key=" + entry.getKey() + ",,value=" + entry.getValue());
+            }
+            Slog.d(TAG, "force stop--super long=" + mSuperLongThreshold + ",,long=" + mLongThreshold + ",,medium=" + mMediumThreshold + ",,short=" + mShortThreshold);
+            mAppCheckerService.printListLog();
+        }
+        for(String forceStopPackage : forceStopList){
+            if(!mPackageUsageRecords.containsKey(forceStopPackage) && isBootKilled(forceStopPackage)){
+                slogd("--forceStopUnuseAppLongTime which not launched--force stop package:" + forceStopPackage);
+                //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+//                forceStopPackage(forceStopPackage, UserHandle.myUserId());
+                forceKillUnusePackage(forceStopPackage, UserHandle.myUserId(), true);
+                //end
+            //}else if((currentTime - mPackageUsageRecords.get(forceStopPackage) >= KILL_APP_TIME_SLONG_THRESHOLD * TIME_MINUTE_UNIT)){
+            }else if(canKill(forceStopPackage, currentTime)){
+//                slogd("--forceStopUnuseAppLongTime--force stop package:" + forceStopPackage);
+                //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+//                forceStopPackage(forceStopPackage, UserHandle.myUserId());
+                forceKillUnusePackage(forceStopPackage, UserHandle.myUserId(), true);
+                mPackageUsageRecords.remove(forceStopPackage);
+                //end
+            }
+        }
+    }
+
+    private boolean isBootKilled(String packageName){
+       AppCheckerInfo info = mAppCheckerService.getAppCheckerInfo(packageName);
+       if(info != null){
+           return info.isBootKill();
+       }
+       return true;
+    }
+
+    private boolean canKill(String packageName, long currentTime) throws RemoteException{
+        long packageExitTime = mPackageUsageRecords.containsKey(packageName) ? mPackageUsageRecords.get(packageName) : 0;
+        slogd("------canKill-----force stop---packageName=" + packageName + "---packageExitTime=" + packageExitTime);
+        if(/*android.os.BlacklistHelper.isInWhiteList(packageName)*/isInLevelList(AppCheckerManager.SUPERLONG_LEVEL, packageName)){
+            if(currentTime - packageExitTime >= mSuperLongThreshold * TIME_MINUTE_UNIT){
+                slogd("--forceStopUnuseAppLongTime--force stop--super long level package:" + packageName);
+                return true;
+            }
+        } else if(/*android.os.BlacklistHelper.isInMediemLevelList(packageName)*/isInLevelList(AppCheckerManager.LONG_LEVEL, packageName)){
+            if(currentTime - packageExitTime >= mLongThreshold * TIME_MINUTE_UNIT){
+                slogd("--forceStopUnuseAppLongTime--force stop--long level package:" + packageName);
+                return true;
+            }
+        }else if(/*android.os.BlacklistHelper.isInLowLevelList(packageName)*/isInLevelList(AppCheckerManager.MEDIUM_LEVEL, packageName)){
+            if(currentTime - packageExitTime >= mMediumThreshold * TIME_MINUTE_UNIT){
+                slogd("--forceStopUnuseAppLongTime--force stop--medium level package:" + packageName);
+                return true;
+            }
+        }else if (isInLevelList(AppCheckerManager.SHORT_LEVEL, packageName)){
+            if(currentTime - packageExitTime >= mShortThreshold* TIME_MINUTE_UNIT){
+                slogd("--forceStopUnuseAppLongTime--force stop--short level package:" + packageName);
+                return true;
+            }
+        } /*else if(currentTime - mPackageUsageRecords.get(packageName) >= SMART_DETECT_TIME_THRESHOLD * TIME_MINUTE_UNIT){
+            slogd("--forceStopUnuseAppLongTime--smart detected--force stop package:" + packageName);
+            return true;
+        }*/
+
+        return false;
+    }
+
+    private boolean isInLevelList(int level, String packageName){
+        List<AppCheckerInfo> list = mAppCheckerService.getLevelList(level);
+        for(AppCheckerInfo appCheckerInfo : list){
+            if(packageName.equals(appCheckerInfo.packageName)){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean isInAppList( List<AppCheckerInfo> list, String packageName){
+        if(list == null) return false;
+        for(AppCheckerInfo appCheckerInfo : list){
+            if(packageName.equals(appCheckerInfo.packageName)){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean isInBlacklist(String packageName) throws RemoteException{
+        //String[] blacklist = BlacklistHelper.getBlackList();
+        List<AppCheckerInfo> blacklist = mAppCheckerService.getSysBlackList();
+        IPackageManager pm = AppGlobals.getPackageManager();
+        for(AppCheckerInfo checker : blacklist){
+            String blacklistItem = checker.packageName;
+            //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+            if(!blacklistItem.equals(packageName)){
+                continue;
+            }
+            //end
+            ApplicationInfo info = null;
+            try {
+                 info = pm.getApplicationInfo(packageName, ApplicationInfo.FLAG_STOPPED, UserHandle.myUserId());
+                 slogd("---force stop--info:" + info + ",,packageName=" + packageName);
+            }catch(RemoteException e){
+                Slog.d(TAG, "force stop--" + e.getMessage());
+                e.printStackTrace();
+            }
+            //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+            if(info != null){
+                if(!info.killed){
+                    return true;
+                }else {
+                    return false;
+                }
+            }
+            //end
+        }
+        return false;
+    }
+
+    private boolean isApplicationStopped(IPackageManager pm, String packageName){
+        ApplicationInfo info = null;
+        try {
+            //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+            info = pm.getApplicationInfo(packageName, 0, UserHandle.myUserId());
+            slogd("--force stop--packageName: " + packageName + ",is killed:" + (info != null ? info.killed : "NULL"));
+            if(info != null 
+                    && ((info.flags & ApplicationInfo.FLAG_STOPPED) == 0)
+                    && !info.killed){
+                slogd("---force stop--is stopped:" + info + ",,packageName=" + packageName);
+                return false;
+            }
+            //end
+        }catch(RemoteException e){
+            Slog.d(TAG, "force stop--" + e.getMessage());
+            e.printStackTrace();
+        }
+        return true;
+    }
+
+    //FEATURE_STOP_APPS end
+    //modified by lixuhui 2015/04/24 modified the solution use killed status instead of stopped status
+    public void forceKillUnusePackage(final String packageName, int userId, boolean cancelJobScheduler) {
+        if (mService.checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES)
+                != PackageManager.PERMISSION_GRANTED) {
+            String msg = "Permission Denial: forceStopPackage() from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid()
+                    + " requires " + android.Manifest.permission.FORCE_STOP_PACKAGES;
+            Slog.w(TAG, msg);
+            throw new SecurityException(msg);
+        }
+        final int callingPid = Binder.getCallingPid();
+        userId = mService.handleIncomingUser(callingPid, Binder.getCallingUid(),
+                userId, true, true, "forceStopPackage", null);
+        long callingId = Binder.clearCallingIdentity();
+        slogd("--forceKillPackage--force stop--is killed:" + packageName);
+        try {
+            IPackageManager pm = AppGlobals.getPackageManager();
+            int appId = 0;
+            synchronized(mService) {
+                
+                int[] users = userId == UserHandle.USER_ALL
+                        ? mService.getUsersLocked() : new int[] { userId };
+                for (int user : users) {
+                    int pkgUid = -1;
+                    try {
+                        pkgUid = pm.getPackageUid(packageName, user);
+                    } catch (RemoteException e) {
+                    }
+                    if (pkgUid == -1) {
+                        Slog.w(TAG, "Invalid packageName: " + packageName);
+                        continue;
+                    }
+                    try {
+                        pm.setPackageKilledState(packageName, true, user);
+                    } catch (RemoteException e) {
+                    } catch (IllegalArgumentException e) {
+                        Slog.w(TAG, "Failed trying to unstop package "
+                                + packageName + ": " + e);
+                    }
+
+                    if (mService.isUserRunningLocked(user, false)) {
+                        mService.forceStopPackageLocked(packageName, pkgUid, "TPW-from pid " + callingPid);
+                    }
+                    //kill the native process associate with this appId, like the deamon process, it will start the killed process again, 
+                    //so we need to kill them
+                    try{
+                        appId = UserHandle.getAppId(
+                                AppGlobals.getPackageManager().getPackageUid(packageName, userId));
+                        if(appId > Process.FIRST_APPLICATION_UID){
+                            final int NN = mService.mProcessCpuTracker.countStats();
+                            for (int in=0; in< NN; in++) {
+                                ProcessCpuTracker.Stats st = mService.mProcessCpuTracker.getStats(in);
+                                if(st.uid == appId && isNativeProcess(st.pid)){
+                                    Process.killProcessQuiet(st.pid);
+                                }
+                            }
+                        }
+                    }catch(Exception e){}
+                }
+            }
+            //cancel the Job scheduler service about the uid, it may restart the app again
+            if(cancelJobScheduler && appId > 0){
+                cancelJobSchedulerForUid(appId);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(callingId);
+        }
+    }
+    
+    private boolean isNativeProcess(int pid){
+        if(mService.mLruProcesses == null) return false;
+        for(ProcessRecord app : mService.mLruProcesses){
+          if(pid == app.pid){
+              return false;
+          }
+        }
+        return true;
+    }
+
+    private void cancelJobSchedulerForUid(int uid){
+        try {
+            JobScheduler mJobScheduler = (JobScheduler) mContext.getSystemService(Context.JOB_SCHEDULER_SERVICE); 
+            mJobScheduler.cancelJobsForUid(uid);
+        } catch(Exception e) {}
+    }
+
+    private void slogd(String message){
+        if(DEBUG_NOT_LAUNCH_CHECK){
+            Slog.d(TAG, message);
+        }
+    }
+
+    public void levelTimeChanged(){
+        initThreshold();
+    }
+
+}
Index: frameworks/base/services/core/java/com/topwise/appchecker/AppCheckerService.java
===================================================================
--- frameworks/base/services/core/java/com/topwise/appchecker/AppCheckerService.java	(revision 0)
+++ frameworks/base/services/core/java/com/topwise/appchecker/AppCheckerService.java	(revision 5734)
@@ -0,0 +1,314 @@
+package com.topwise.appchecker;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Process;
+import android.util.Log;
+
+import java.util.List;
+
+import com.android.server.ServiceThread;
+import com.topwise.appcheck.IAppChecker;
+import com.topwise.appcheck.IAppCheckStoreObserver;
+import com.topwise.appcheck.AppCheckerInfo;
+
+/**
+ * Created by huangxunwan on 9/22/16.
+ */
+public class AppCheckerService extends com.android.server.SystemService{
+    static boolean DEBUG = false;
+    static final String TAG = "AppCheckerService";
+
+    final AppCheckerStub mAppCheckerStub;
+    final AppCheckStore mStore;
+
+    final ServiceThread mHandlerThread;
+    final Context mContext;
+    final Handler mHandler;
+
+
+    /**
+     * Initializes the system service.
+     * <p>
+     * Subclasses must define a single argument constructor that accepts the context
+     * and passes it to super.
+     * </p>
+     *
+     * @param context The system server context.
+     */
+    public AppCheckerService(Context context) {
+        super(context);
+        mContext = context;
+        mAppCheckerStub = new AppCheckerStub();
+        mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true);
+        mHandlerThread.start();
+        mHandler = new Handler(mHandlerThread.getLooper()){
+            @Override
+            public void handleMessage(Message msg) {
+                switch (msg.what){
+                    case AppCheckStore.STORE_CHANGE_MSG:
+                        AppCheckStore.Goods goods = (AppCheckStore.Goods) msg.obj;
+                        mStore.notifyObserver(goods.isReset, goods.info, goods.oldLevel, goods.newLevel, goods.bootStart);
+                        break;
+                    case AppCheckStore.STORE_SAVE_MSG:
+                        int userId = msg.arg1;
+                        mStore.notifyWriteAppInfo(userId);
+                        break;
+                    case AppCheckStore.STORE_RESET_MSG:
+                        mStore.notifyResetAppInfo(0);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        };
+        mStore = new AppCheckStore(mHandler, context);
+        mStore.start();
+    }
+
+    @Override
+    public void onStart() {
+        try {
+            publishBinderService("appchecker", mAppCheckerStub);
+        }catch (Exception e){
+            android.util.Log.d(TAG, e.toString());
+        }
+        Log.d(TAG, "appchecker begin...");
+    }
+
+    public int getLevel(String pkgName){
+        return mStore.getLevel(pkgName);
+    }
+
+    public void setLevel(String pkgName, int level){
+        mStore.setLevel(pkgName, level);
+    }
+
+    public AppCheckerInfo getAppCheckerInfo(String packageName){
+        return  mStore.getAppCheckerInfo(packageName);
+    }
+
+    public List<AppCheckerInfo> getLevelList(int level){
+        return mStore.getLevelList(level);
+    }
+
+    public int getLevelTime(int level){
+        return mStore.getLevelTime(level);
+    }
+
+    public void setLevelTime(String levelTime){
+        mStore.setLevelTime(levelTime);
+       if(mLevelTimeChangedListener != null){
+           mLevelTimeChangedListener.levelTimeChanged();
+       }
+    }
+
+    public List<AppCheckerInfo> getForceStopList(){
+        return mStore.getForceStopList();
+    }
+
+    public List<AppCheckerInfo> getExcludeList(){
+        return mStore.getExcludeList();
+    }
+    public List<AppCheckerInfo> getSysBlackList(){
+        return mStore.getSysBlackList();
+    }
+
+    public List<AppCheckerInfo> getPersistList(){
+        return mStore.getPersistList();
+    }
+
+    public List<AppCheckerInfo> getNoPersistList(){
+        return mStore.getNoPersistList();
+    }
+
+    public void setAutoBootEnabled(String pkgName, boolean state){
+        int flag = 0;
+        PackageInfo info = null;
+        try{
+            info = mContext.getPackageManager().getPackageInfo(pkgName, 0);
+            flag = info.applicationInfo.flags;
+        } catch (PackageManager.NameNotFoundException e) {
+            return;
+        }
+        mStore.setAutoBootEnabled(pkgName, state, flag);
+    }
+
+    public void registerCheckerObserver(IAppCheckStoreObserver observer){
+        mStore.registerCheckerObserver(observer);
+    }
+
+    void resetAppCheckerInfo(){
+        mStore.scheduleResetAppInfo();
+    }
+
+    public void printListLog(){
+        mStore.printListLog();
+    }
+
+    public void enableLog(boolean enable){
+        DEBUG = enable;
+        if(mStore != null){
+            mStore.enableLog(enable);
+        }
+    }
+
+    public interface LevelTimeChangedListener{
+        public void levelTimeChanged();
+    }
+
+    LevelTimeChangedListener mLevelTimeChangedListener;
+
+    public void registerLevelTimeChangedListener(LevelTimeChangedListener listener){
+        mLevelTimeChangedListener = listener;
+    }
+
+    /**
+     * Binder stub trampoline implementation
+     */
+    final class AppCheckerStub extends IAppChecker.Stub {
+
+        @Override
+        public int getLevel(String pkgName){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getLevel(pkgName);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        @Override
+        public void setLevel(String pkgName, int level){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                AppCheckerService.this.setLevel(pkgName, level);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        @Override
+        public List<AppCheckerInfo> getLevelList(int level){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getLevelList(level);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        @Override
+        public int getLevelTime(int level){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getLevelTime(level);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        @Override
+        public List<AppCheckerInfo> getForceStopList(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getForceStopList();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        @Override
+        public List<AppCheckerInfo> getExcludeList(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getExcludeList();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+         @Override
+        public List<AppCheckerInfo> getSysBlackList(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getSysBlackList();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public List<AppCheckerInfo> getPersistList(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getPersistList();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public List<AppCheckerInfo> getNoPersistList(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return AppCheckerService.this.getNoPersistList();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+        
+        @Override
+        public void setAutoBootEnabled(String pkgName, boolean state){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                AppCheckerService.this.setAutoBootEnabled(pkgName, state);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void registerCheckerObserver(IAppCheckStoreObserver observer){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                AppCheckerService.this.registerCheckerObserver(observer);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void resetAppCheckerInfo(){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                AppCheckerService.this.resetAppCheckerInfo();
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+
+        @Override
+        public void setLevelTime(String levelTime){
+            final int uid = Binder.getCallingUid();
+            long ident = Binder.clearCallingIdentity();
+            try {
+                AppCheckerService.this.setLevelTime(levelTime);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+
+}
+
Index: frameworks/base/services/core/java/com/topwise/appchecker/AppCheckStore.java
===================================================================
--- frameworks/base/services/core/java/com/topwise/appchecker/AppCheckStore.java	(revision 0)
+++ frameworks/base/services/core/java/com/topwise/appchecker/AppCheckStore.java	(revision 5734)
@@ -0,0 +1,942 @@
+package com.topwise.appchecker;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteCallbackList;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.util.ArrayMap;
+import android.util.Log;
+import android.util.Xml;
+import android.widget.Switch;
+
+import com.android.internal.content.PackageMonitor;
+import com.android.internal.util.FastXmlSerializer;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.topwise.appcheck.IAppCheckStoreObserver;
+import com.topwise.appcheck.AppCheckerManager;
+import com.topwise.appcheck.AppCheckerInfo;
+
+/**
+ * Created by huangxunwan on 9/23/16.
+ */
+public class AppCheckStore {
+
+    private static final String TAG = "AppCheckStore";
+    private static boolean DEBUG = false;
+
+    public final static int STORE_CHANGE_MSG = 1;
+    public final static int STORE_SAVE_MSG = 0;
+    public final static int STORE_RESET_MSG = 2;
+
+   final ArrayMap<String, AppCheckerInfo> mPkg = new ArrayMap<String, AppCheckerInfo>();
+
+    List<AppCheckerInfo> mShortPkg = new ArrayList<>();
+    List<AppCheckerInfo> mMediumPkg = new ArrayList<>();
+    List<AppCheckerInfo> mLongPkg = new ArrayList<>();
+    List<AppCheckerInfo> mSuperLongPkg = new ArrayList<>();
+    List<AppCheckerInfo> mNoCheckPkg = new ArrayList<>();
+    List<AppCheckerInfo> mExcludePkg = new ArrayList<>();
+
+    List<AppCheckerInfo> mKillInRoot = new ArrayList<>();
+
+    List<AppCheckerInfo> mSysAppToKill = new ArrayList<>();
+    List<AppCheckerInfo> mExclude3rdApp = new ArrayList<>();
+
+    List<AppCheckerInfo> mPersistApp = new ArrayList<>(); 
+    List<AppCheckerInfo> mNoPersistApp = new ArrayList<>(); 
+
+    protected int mSuperLongTime = 0;
+    protected int mLongTime = 0;
+    protected int mMediumTime = 0;
+    protected int mShortTime = 0;
+
+    private final Handler mHandler;
+    private final Context mContext;
+
+    private AppCheckStoreMonitor mMonitor= new AppCheckStoreMonitor();
+
+    private RemoteCallbackList<IAppCheckStoreObserver> mObservers = new RemoteCallbackList<IAppCheckStoreObserver>();
+
+    public AppCheckStore(Handler handler, Context ctx){
+        mHandler = handler;
+        mContext = ctx;
+    }
+
+    public void start(){
+        mMonitor.register(mContext, null, true);
+        Runnable r = new Runnable(){
+            @Override
+            public void run() {
+                synchronized (mPkg) {
+                    if (!getUserAppcheckerFile(0).exists()) {
+                        loadDefaultPkgFile();
+                    } else {
+                        readAppCheckerInfo(0);
+                    }
+                    seekAndFilterApps(mContext);
+                    writeAppCheckerInfo(0);
+                }
+            }
+        };
+        if (mHandler.getLooper() == Looper.myLooper()){
+            r.run();
+        }else{
+            mHandler.postAtFrontOfQueue(r);
+        }
+    }
+
+    public void notifyWriteAppInfo(int userId){
+        synchronized (mPkg) {
+            writeAppCheckerInfo(0);
+        }
+    }
+
+    public void notifyResetAppInfo(int userId){
+        synchronized (mPkg){
+            clearAllListInfo();
+            loadDefaultPkgFile();
+            seekAndFilterApps(mContext);
+            scheduleWriteAppCheckerInfo(userId);
+            scheduleNotifyUpdate(new Goods(true, null, 0, 0, false));
+        }
+    }
+
+    public void scheduleWriteAppCheckerInfo(int userId){
+        mHandler.removeMessages(STORE_SAVE_MSG);
+        final Message message = mHandler.obtainMessage(STORE_SAVE_MSG, userId);
+        mHandler.sendMessageDelayed(message, 800);
+    }
+
+    public void scheduleNotifyUpdate(Goods goods){
+        mHandler.sendMessage(mHandler.obtainMessage(STORE_CHANGE_MSG, goods));
+    }
+
+    public void scheduleResetAppInfo(){
+        mHandler.sendEmptyMessage(STORE_RESET_MSG);
+    }
+
+    public int getLevel(String pkgName){
+        synchronized (mPkg) {
+            return mPkg.get(pkgName).level;
+        }
+    }
+
+    void setLevel(String pkgName, int level){
+        synchronized (mPkg) {
+            AppCheckerInfo info = mPkg.get(pkgName);
+            int oldLevel = info.level;
+            getLevelList(oldLevel).remove(info);
+            info.level = level;
+            addPkg(getLevelList(level), info);
+            printListLog();
+            scheduleWriteAppCheckerInfo(0);
+            scheduleNotifyUpdate(new Goods(false, info, oldLevel, level, info.isBootKill()));
+        }
+    }
+
+    public AppCheckerInfo getAppCheckerInfo(String packageName){
+        return mPkg.get(packageName);
+    }
+
+    List<AppCheckerInfo> getLevelList(int level){
+        synchronized (mPkg) {
+            switch (level) {
+                case AppCheckerManager.SHORT_LEVEL:
+                    return mShortPkg;
+                case AppCheckerManager.MEDIUM_LEVEL:
+                    return mMediumPkg;
+                case AppCheckerManager.LONG_LEVEL:
+                    return mLongPkg;
+                case AppCheckerManager.SUPERLONG_LEVEL:
+                    return mSuperLongPkg;
+                case AppCheckerManager.NO_CHECK_LEVEL:
+                    return mNoCheckPkg;
+                case AppCheckerManager.EXCLUDE_LEVEL:
+                    return mExcludePkg;
+            }
+            throw new IllegalArgumentException("Invalid level: " + level);
+        }
+    }
+
+    int getLevelTime(int level){
+        switch (level) {
+                case AppCheckerManager.SHORT_LEVEL:
+                    return mShortTime;
+                case AppCheckerManager.MEDIUM_LEVEL:
+                    return mMediumTime;
+                case AppCheckerManager.LONG_LEVEL:
+                    return mLongTime;
+                case AppCheckerManager.SUPERLONG_LEVEL:
+                    return mSuperLongTime;
+            }
+            throw new IllegalArgumentException("Invalid time level: " + level);
+    }
+
+    void setLevelTime(String levelTime){
+
+        if(levelTime == null || levelTime.trim().isEmpty()) return;
+
+        String[] levelTimes = levelTime.trim().split(",");
+        if(levelTimes == null || levelTimes.length < 4) return;
+        mShortTime = Integer.valueOf(levelTimes[0]);
+        mMediumTime = Integer.valueOf(levelTimes[1]);
+        mLongTime = Integer.valueOf(levelTimes[2]);
+        mSuperLongTime = Integer.valueOf(levelTimes[3]);
+
+        scheduleWriteAppCheckerInfo(0);
+    }
+
+    List<AppCheckerInfo> getForceStopList(){
+        synchronized (mKillInRoot) {
+            return mKillInRoot;
+        }
+    }
+
+    List<AppCheckerInfo> getExcludeList(){
+        synchronized (mExclude3rdApp) {
+            return mExclude3rdApp;
+        }
+    }
+    List<AppCheckerInfo> getSysBlackList(){
+        synchronized (mSysAppToKill) {
+            return mSysAppToKill;
+        }
+    }
+ 
+    List<AppCheckerInfo> getPersistList(){
+        synchronized (mPersistApp) {
+            return mPersistApp;
+        }
+    }
+
+    List<AppCheckerInfo> getNoPersistList(){
+        synchronized (mNoPersistApp) {
+            return mNoPersistApp;
+        }
+    }
+
+    void setAutoBootEnabled(String pkgName, boolean state, int flag){
+        AppCheckerInfo info = null;
+        synchronized (mPkg){
+            info = mPkg.get(pkgName);
+            info.bootKill = state ? 1 : 0;
+            if (state == true){
+                mKillInRoot.add(info);
+            }else {
+                mKillInRoot.remove(info);
+            }
+            printListLog();
+            scheduleWriteAppCheckerInfo(0);
+            scheduleNotifyUpdate(new Goods(false, info, info.level, info.level, state));
+        }
+    }
+
+    public void registerCheckerObserver(IAppCheckStoreObserver observer){
+        if (observer == null)    return;
+        mObservers.register(observer);
+    }
+
+    void notifyObserver(boolean reset, AppCheckerInfo info, int oldLevel, int newLevel, boolean bootStart){
+        int num = mObservers.beginBroadcast();
+        while(num > 0){
+            num--;
+            try{
+                mObservers.getBroadcastItem(num).appStoreChange(reset, info, oldLevel, newLevel, bootStart);
+            } catch (RemoteException e){
+                // Handled by the RemoteCallbackList
+            }
+        }
+        mObservers.finishBroadcast();
+    }
+
+    void readAppCheckerInfo(int userId){
+        clearAllListInfo();
+        FileInputStream str = null;
+        File readFile = getUserAppcheckerFile(userId);
+        if (readFile.exists()){
+            try {
+                str = new FileInputStream(readFile);
+                final XmlPullParser parser = Xml.newPullParser();
+                parser.setInput(str, StandardCharsets.UTF_8.name());
+
+                int type;
+                while ((type=parser.next())!=XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT){
+                    ;
+                }
+
+                if (type != XmlPullParser.START_TAG)    return;
+
+                int outerDepth = parser.getDepth();
+                while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
+                        && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)){
+                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT)    continue;
+
+                    String tagName = parser.getName();
+                    collectAppAndTime(parser, tagName);
+                }
+
+                str.close();
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            } catch (XmlPullParserException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        if (DEBUG){
+            Log.d(TAG, "readAppCheckerInfo():  ");
+            Log.d(TAG, "mPkg size: " + mPkg.size());
+            Log.d(TAG, "mSysAppToKill size: " + mSysAppToKill.size());
+            Log.d(TAG, "mExclude3rdApp size: " + mExclude3rdApp.size());
+            printListLog();
+        }
+    }
+
+    void writeAppCheckerInfo(int userId){
+        synchronized (mPkg) {
+            File saveFile = getUserAppcheckerFile(userId);
+            if (DEBUG){
+                Log.d(TAG, "writeAppCheckerInfo userId: " + userId);
+            }
+            new File(saveFile.getParent()).mkdirs();
+            try {
+                final FileOutputStream fstr = new FileOutputStream(saveFile);
+                final BufferedOutputStream str = new BufferedOutputStream(fstr);
+
+                final XmlSerializer serializer = new FastXmlSerializer();
+                serializer.setOutput(str, StandardCharsets.UTF_8.name());
+                serializer.startDocument(null, true);
+                serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+
+                serializer.startTag(null, "appchecker");
+
+                serializer.startTag(null, "time");
+                serializer.attribute(null, "superlong", String.valueOf(mSuperLongTime));
+                serializer.attribute(null, "long", String.valueOf(mLongTime));
+                serializer.attribute(null, "medium", String.valueOf(mMediumTime));
+                serializer.attribute(null, "short", String.valueOf(mShortTime));
+                serializer.endTag(null, "time");
+
+                serializer.startTag(null, "pkgs");
+                for (String i : mPkg.keySet()){
+                    serializer.startTag(null, "package");
+                    serializer.attribute(null, "name", i);
+                    serializer.attribute(null, "level", mPkg.get(i).level + "");
+                    serializer.attribute(null, "kill", mPkg.get(i).bootKill + "");
+                    serializer.endTag(null, "package");
+                }
+                serializer.endTag(null, "pkgs");
+                serializer.startTag(null, "systemblack");
+                for(AppCheckerInfo i : mSysAppToKill){
+                    if(i != null){
+                        serializer.startTag(null, "package");
+                        serializer.attribute(null, "name", i.packageName);
+                        serializer.endTag(null, "package");
+                    }
+                }
+                serializer.endTag(null, "systemblack");
+                serializer.startTag(null, "white3rd");
+                for(AppCheckerInfo i : mExclude3rdApp){
+                    if(i != null){
+                        serializer.startTag(null, "package");
+                        serializer.attribute(null, "name", i.packageName);
+                        serializer.endTag(null, "package");
+                    }
+                }
+                serializer.endTag(null, "white3rd");
+                serializer.startTag(null, "persist");
+                for (AppCheckerInfo i : mPersistApp){
+                    if(i != null){
+                        serializer.startTag(null, "package");
+                        serializer.attribute(null, "name", i.packageName);
+                        serializer.endTag(null, "package");
+                    }
+                }
+                serializer.endTag(null, "persist");
+
+                serializer.startTag(null, "nopersist");
+                for (AppCheckerInfo i : mNoPersistApp){
+                    if(i != null){
+                        serializer.startTag(null, "package");
+                        serializer.attribute(null, "name", i.packageName);
+                        serializer.endTag(null, "package");
+                    }
+                }
+                serializer.endTag(null, "nopersist");
+                
+                serializer.endTag(null, "appchecker");
+
+                serializer.endDocument();
+                str.flush();
+                FileUtils.sync(fstr);
+                str.close();
+
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    File getUserAppcheckerFile(int userId){
+        File dir = new File(new File(Environment.getDataDirectory(), "system"), "users");
+        File userDir = new File(dir, Integer.toString(userId));
+        return new File(userDir, "appchecker.xml");
+    }
+
+    void loadDefaultPkgFile(){
+        clearAllListInfo();
+        FileInputStream str = null;
+        File defFile = getDefaultFile();
+        try {
+            if (defFile.exists()){
+                str = new FileInputStream(defFile);
+            }
+            if (str == null){
+                //throw new IllegalStateException(defFile + "Cant get Default infomation");
+                android.util.Log.d(TAG, defFile + " Cant get Default infomation");
+                return;
+            }
+            final XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(str,StandardCharsets.UTF_8.name());
+
+            int type;
+            while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT){
+                ;
+            }
+            int outerDepth = parser.getDepth();
+            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)){
+                if (type == XmlPullParser.END_TAG
+                        || type == XmlPullParser.TEXT) {
+                    continue;
+                }
+                String tagName = parser.getName();
+                collectAppAndFirstTime(parser, tagName);
+            }
+            str.close();
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (XmlPullParserException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    void seekAndFilterApps(Context ctx){
+        final long getTime = DEBUG ? SystemClock.uptimeMillis() : 0;
+        List<PackageInfo> allApps = getAllApps(ctx);
+        if (DEBUG) {
+            Log.d(TAG, "getAllapps took "
+                    + (SystemClock.uptimeMillis()-getTime) + "ms");
+            Log.d(TAG, "queryIntentActivities got " + allApps.size() + " apps");
+        }
+
+        final long filterTime = DEBUG ? SystemClock.uptimeMillis() : 0;
+        //no need to care the bootkill without in config file
+        for(PackageInfo info : allApps){
+            if (mPkg.containsKey(info.packageName)){
+                continue;
+            }
+            int bootkill = 0;
+            if(isSystemApp(info)){
+                bootkill = 0;
+                AppCheckerInfo checkerInfo = new AppCheckerInfo(info.packageName, AppCheckerManager.EXCLUDE_LEVEL, bootkill);
+                if (DEBUG) {
+                    Log.d(TAG, "SYSTEM APP: info.packageName is " + info.packageName);
+                }
+                mPkg.put(info.packageName, checkerInfo);
+                /*
+                if(!mPkg.containsKey(info.packageName)) {
+                    mPkg.put(info.packageName, NO_CHECK_LEVEL);
+                    addPkg(mNoCheckPkg, info.packageName);
+                }*/
+            } else {
+                if (DEBUG) {
+                    Log.d(TAG, "3RD APP: info.packageName is " + info.packageName);
+                }
+                bootkill = 1;
+                AppCheckerInfo checkerInfo = new AppCheckerInfo(info.packageName, AppCheckerManager.SHORT_LEVEL, bootkill);
+                if(!mPkg.containsKey(info.packageName)) {
+                    mPkg.put(checkerInfo.packageName, checkerInfo);
+                }
+                addPkg(mKillInRoot, checkerInfo);
+                addPkg(mShortPkg, checkerInfo);
+            }
+        }
+        if (DEBUG) {
+            Log.d(TAG, "filterapps took "
+                    + (SystemClock.uptimeMillis()-filterTime) + "ms");
+            Log.d(TAG, "filterapps " + allApps.size() + " apps");
+        }
+        printListLog();
+    }
+
+    List<PackageInfo> getAllApps(Context ctx){
+        PackageManager pm = ctx.getPackageManager();
+        return pm.getInstalledPackages(0);
+    }
+
+    boolean isSystemApp(PackageInfo pi){
+        if (pi == null)    return false;
+        return (pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0 || (pi.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0;
+    }
+
+    private void collectAppAndFirstTime(XmlPullParser parser, String tagName) throws XmlPullParserException, IOException {
+        List choice = null;
+        int type;
+        int outerDepth = parser.getDepth();
+        if ("time".equals(tagName)){
+            String attrSl = parser.getAttributeValue(null, "superlong");
+            String attrL = parser.getAttributeValue(null, "long");
+            String attrM = parser.getAttributeValue(null, "medium");
+            String attrS = parser.getAttributeValue(null, "short");
+
+            mSuperLongTime = attrSl == null ? 0 : Integer.parseInt(attrSl);
+            mLongTime = attrL== null ? 0 : Integer.parseInt(attrL);
+            mMediumTime= attrM== null ? 0 : Integer.parseInt(attrM);
+            mShortTime= attrS == null ? 0 : Integer.parseInt(attrS);
+        }
+        
+        AppCheckerInfo info = null;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)){
+            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) continue;
+            if ("package".equals(parser.getName())){
+                String pkg = parser.getAttributeValue(null, "name");
+                String killStr = parser.getAttributeValue(null, "kill");              
+                int bootKill = killStr == null ? 1 : Integer.parseInt(killStr);
+                
+                if ("short-pkg".equals(tagName)){
+                    choice = mShortPkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.SHORT_LEVEL, bootKill);
+                    mPkg.put(pkg, info);
+                }else if ("medium-pkg".equals(tagName)){
+                    choice = mMediumPkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.MEDIUM_LEVEL, bootKill);
+                    mPkg.put(pkg, info);
+                }else if ("long-pkg".equals(tagName)){
+                    choice = mLongPkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.LONG_LEVEL, bootKill);
+                    mPkg.put(pkg, info);
+                }else if ("superlong-pkg".equals(tagName)){
+                    choice = mSuperLongPkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.SUPERLONG_LEVEL, bootKill);
+                    mPkg.put(pkg, info);
+                }else if ("nocheck-pkg".equals(tagName)){
+                    choice = mNoCheckPkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.NO_CHECK_LEVEL, bootKill);
+                    mPkg.put(pkg, info);
+                }else if ("systemblack-pkg".equals(tagName)){
+                    info = mPkg.get(pkg);
+                    if(info == null){
+                        info = new AppCheckerInfo(pkg, AppCheckerManager.SHORT_LEVEL, bootKill);
+                        choice = mShortPkg;
+                        mPkg.put(pkg, info);
+                    }
+                    info.bootKill = bootKill;
+                    addPkg(mSysAppToKill, info);
+                }else if ("white3rd-pkg".equals(tagName)){
+                    choice = mExcludePkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.EXCLUDE_LEVEL, 0);
+                    addPkg(mExclude3rdApp, info);
+                    mPkg.put(pkg, info);
+                }/*else if ("persist-pkg".equals(tagName)){
+                    choice = mExcludePkg;
+                    info = new AppCheckerInfo(pkg, AppCheckerManager.EXCLUDE_LEVEL, 0);
+                    addPkg(mPersistApp, info);
+                    //mPkg.put(pkg, info);
+                }else if ("nopersist-pkg".equals(tagName)){
+                    choice = null;
+                    info = new AppCheckerInfo(pkg, 0, 0);
+                    addPkg(mNoPersistApp, info);
+                    //add to mPkg in seek other apps
+                    //mPkg.put(pkg, info);
+                }*/
+
+                
+                if (choice != null && info != null)
+                {
+                    addPkg(choice, info);
+                    choice = null;
+                }
+
+                if (bootKill == 1 && info != null){
+                    addPkg(mKillInRoot, info);
+                }
+                info = null;
+            }
+        }
+        verifyAppList();
+    }
+
+    private void collectAppAndTime(XmlPullParser parser, String tagName) throws XmlPullParserException, IOException {
+        List choice = null;
+        int type;
+        int outerDepth = parser.getDepth();
+        if ("time".equals(tagName)){
+            String attrSl = parser.getAttributeValue(null, "superlong");
+            String attrL = parser.getAttributeValue(null, "long");
+            String attrM = parser.getAttributeValue(null, "medium");
+            String attrS = parser.getAttributeValue(null, "short");
+
+            mSuperLongTime = attrSl == null ? 0 : Integer.parseInt(attrSl);
+            mLongTime = attrL== null ? 0 : Integer.parseInt(attrL);
+            mMediumTime= attrM== null ? 0 : Integer.parseInt(attrM);
+            mShortTime= attrS == null ? 0 : Integer.parseInt(attrS);
+        }
+        
+        AppCheckerInfo info = null;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)){
+            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) continue;
+            if ("package".equals(parser.getName())){
+                String pkg = parser.getAttributeValue(null, "name");
+                String killStr = parser.getAttributeValue(null, "kill");              
+                int bootKill = killStr == null ? 1 : Integer.parseInt(killStr);
+
+                if ("pkgs".equals(tagName)){
+                    int level = Integer.parseInt(parser.getAttributeValue(null, "level"));
+                    info = new AppCheckerInfo(pkg, level, bootKill);
+                    mPkg.put(info.packageName, info);
+                    switch (level){
+                        case AppCheckerManager.SHORT_LEVEL:
+                            addPkg(mShortPkg, info);
+                            break;
+                        case AppCheckerManager.MEDIUM_LEVEL:
+                            addPkg(mMediumPkg, info);
+                            break;
+                        case AppCheckerManager.LONG_LEVEL:
+                            addPkg(mLongPkg, info);
+                            break;
+                        case AppCheckerManager.SUPERLONG_LEVEL:
+                            addPkg(mSuperLongPkg, info);
+                            break;
+                        case AppCheckerManager.NO_CHECK_LEVEL:
+                            addPkg(mNoCheckPkg, info);
+                            break;
+                        case AppCheckerManager.EXCLUDE_LEVEL:
+                            addPkg(mExcludePkg, info);
+                            break;
+                        default:
+                            break;
+                    }
+                }else if ("systemblack".equals(tagName)){
+                    Log.d(TAG, "systemblack...");
+                    addPkg(mSysAppToKill, mPkg.get(pkg));
+                }else if ("white3rd".equals(tagName)){
+                    addPkg(mExclude3rdApp, mPkg.get(pkg));
+                }else if ("persist".equals(tagName)){
+                    //addPkg(mPersistApp, mPkg.get(pkg));
+                }else if ("nopersist".equals(tagName)){
+                    //addPkg(mNoPersistApp, mPkg.get(pkg));
+                }
+
+                if (bootKill == 1 && info != null){
+                    addPkg(mKillInRoot, info);
+                }
+                info = null;
+            }
+        }
+        verifyAppList();
+    }
+
+    private void verifyAppList(){
+      // TODO: verify appchecker info list are not conflicting   
+    }
+
+    private void clearAllListInfo(){
+        synchronized (mPkg){
+            synchronized (mPersistApp){
+                mPkg.clear();
+                mShortPkg.clear();
+                mMediumPkg.clear();
+                mLongPkg.clear();
+                mSuperLongPkg.clear();
+                mExcludePkg.clear();
+                mExclude3rdApp.clear();
+                mSysAppToKill.clear();
+                mPersistApp.clear();
+                mNoPersistApp.clear();
+                mKillInRoot.clear();
+            }
+        }
+    }
+
+    public void printListLog(){
+        if (!DEBUG) {
+            return;
+        }
+        Log.d(TAG, "mPkg: ------------------------------------------------------->");
+        for (String key : mPkg.keySet()){
+            Log.d(TAG, "key: " + key + " info: " + mPkg.get(key));
+        }
+        Log.d(TAG, "mPkg: <----------------------------------------------------------");
+        
+        Log.d(TAG, "mKillInRoot: ------------------------------------------------->");
+        for (AppCheckerInfo info : mKillInRoot){
+            if(info != null){
+                Log.d(TAG, "kill " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mKillInRoot: <-------------------------------------------------");
+        
+        Log.d(TAG, "mExclude3rdApp: ------------------------------------------------->");
+        for (AppCheckerInfo info : mExclude3rdApp){
+            if(info != null){
+                Log.d(TAG, "mExclude3rdApp " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mExclude3rdApp: <----------------------------------------------------");
+        
+        Log.d(TAG, "mPersistApp: ------------------------------------------------->");
+        for (AppCheckerInfo info : mPersistApp){
+            if(info != null){
+                Log.d(TAG, "mPersistApp " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mPersistApp: <----------------------------------------------------");
+
+        Log.d(TAG, "mNoPersistApp: ------------------------------------------------->");
+        for (AppCheckerInfo info : mNoPersistApp){
+            if(info != null){
+                Log.d(TAG, "mNoPersistApp " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mNoPersistApp: <----------------------------------------------------");
+        
+        Log.d(TAG, "mSysAppToKill: ------------------------------------------------->");
+        for (AppCheckerInfo info : mSysAppToKill){
+            if(info != null){
+                Log.d(TAG, "mSysAppToKill " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mSysAppToKill: <----------------------------------------------------");
+        
+        Log.d(TAG, "mShortPkg: ------------------------------------------------->");
+        for (AppCheckerInfo info : mShortPkg){
+            if(info != null){
+                Log.d(TAG, "mShortPkg " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mShortPkg: <----------------------------------------------------");
+
+        Log.d(TAG, "mMediumPkg: ------------------------------------------------->");
+        for (AppCheckerInfo info : mMediumPkg){
+            if(info != null){
+                Log.d(TAG, "mMediumPkg " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mMediumPkg: <----------------------------------------------------");
+
+        Log.d(TAG, "mLongPkg: ------------------------------------------------->");
+        for (AppCheckerInfo info : mLongPkg){
+            if(info != null){
+                Log.d(TAG, "mLongPkg " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mLongPkg: <----------------------------------------------------");
+
+        Log.d(TAG, "mSuperLongPkg: ------------------------------------------------->");
+        for (AppCheckerInfo info : mSuperLongPkg){
+            if(info != null){
+                Log.d(TAG, "mSuperLongPkg " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mSuperLongPkg: <----------------------------------------------------");
+
+        Log.d(TAG, "mExcludePkg: ------------------------------------------------->");
+        for (AppCheckerInfo info : mExcludePkg){
+            if(info != null){
+                Log.d(TAG, "mExcludePkg " + info.packageName);
+            }
+        }
+        Log.d(TAG, "mExcludePkg: <----------------------------------------------------");
+    }
+
+    public void enableLog(boolean enable){
+        DEBUG = enable;
+    }
+
+    File getDefaultFile(){
+        return new File(SystemProperties.get("ro.checkapp.default", "/system/etc/default_appcheck.xml"));
+    }
+
+    private <T> void addPkg(List<T> list, T info){
+        if (list == null) return;
+        if (!list.contains(info)){
+            list.add(info);
+        }
+    }
+
+    private void handlePackageDisappeared(String pkgName){
+        synchronized (mPkg){
+            AppCheckerInfo info = mPkg.get(pkgName);
+            getLevelList(info.level).remove(info);
+            PackageInfo pi = null;
+            try {
+                 pi = mContext.getPackageManager().getPackageInfo(pkgName, 0);
+            }catch (PackageManager.NameNotFoundException e) {
+            }
+            
+            if (mKillInRoot.contains(info)){
+                mKillInRoot.remove(info);
+            }
+            if (pi != null && isSystemApp(pi)) {
+                mSysAppToKill.remove(info);
+            }else{
+                mExclude3rdApp.remove(pkgName);
+            }
+            
+            mPkg.remove(pkgName);
+            scheduleWriteAppCheckerInfo(0);
+            scheduleNotifyUpdate(new Goods(false, info, info.level, 0 , false));
+        }
+    }
+
+    private void handlePackageAppeared(String pkgName){
+        synchronized (mPkg){
+            try {
+                PackageInfo pi = mContext.getPackageManager().getPackageInfo(pkgName, 0);
+                AppCheckerInfo info = null;
+                if (mPkg.containsKey(pkgName)){
+                    info = mPkg.get(pkgName);
+                    scheduleNotifyUpdate(new Goods(false, info, 0, info.level, info.bootKill == 1));
+                    return;
+                }
+                
+                int level = 0;
+                if (isSystemApp(pi)){
+                    level = AppCheckerManager.EXCLUDE_LEVEL;
+                    info = new AppCheckerInfo(pkgName, level, 0);
+                    addPkg(mExcludePkg, info);
+                }else{
+                    level = AppCheckerManager.SHORT_LEVEL;
+                    info = new AppCheckerInfo(pkgName, level, 1);
+                    addPkg(mShortPkg, info);
+                    addPkg(mKillInRoot, info);
+                }
+                mPkg.put(pkgName, info);
+                scheduleWriteAppCheckerInfo(0);
+                scheduleNotifyUpdate(new Goods(false, info, 0, level, info.bootKill == 1));
+            } catch (PackageManager.NameNotFoundException e) {
+
+            }
+        }
+    }
+
+    private boolean handlePackageChanged(boolean overall, String pkgName){
+        if (!overall)    return overall;
+
+        PackageInfo pi = null;
+        boolean enable = false;
+        AppCheckerInfo info = null;
+        int level = 0;
+        try {
+            pi = mContext.getPackageManager().getPackageInfo(pkgName, 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        if (pi != null){
+            enable = pi.applicationInfo.enabled;
+        }
+        if (enable){
+            if (mPkg.containsKey(pkgName)){
+                return overall;
+            }
+            if(isSystemApp(pi)){
+                level = AppCheckerManager.EXCLUDE_LEVEL;
+                info = new AppCheckerInfo(pkgName, level, 0);
+                addPkg(mExcludePkg, info);            
+            }else{
+                level = AppCheckerManager.SHORT_LEVEL;
+                info = new AppCheckerInfo(pkgName, level, 1);
+                addPkg(mMediumPkg, info);
+                addPkg(mKillInRoot, info);
+            }
+            mPkg.put(pkgName, info);
+            scheduleNotifyUpdate(new Goods(false, info, 0, level, info.level == 1));
+        }else {
+            //disable
+        }
+        scheduleWriteAppCheckerInfo(0);
+
+        return overall;
+    }
+
+    final class AppCheckStoreMonitor extends PackageMonitor{
+        @Override
+        public void onPackageDisappeared(String packageName, int reason) {
+            super.onPackageDisappeared(packageName, reason);
+        //    handlePackageDisappeared(packageName);
+            if(DEBUG){
+                Log.d(TAG, "onPackageDisappeared-- packageName: " + packageName + "reason: " + reason);
+            }
+        }
+
+        @Override
+        public void onPackageAppeared(String packageName, int reason) {
+            super.onPackageAppeared(packageName, reason);
+            handlePackageAppeared(packageName);
+            if(DEBUG){
+                Log.d(TAG, "onPackageAppeared-- packageName: " + packageName + " reason: " + reason);
+            }
+        }
+
+        @Override
+        public boolean onPackageChanged(String packageName, int uid, String[] components) {
+            boolean overall = super.onPackageChanged(packageName, uid, components);
+            //boolean result = handlePackageChanged(overall, packageName);
+
+            if(DEBUG){
+                Log.d(TAG, "onPackageChanged-- packageName: " + packageName + ", overall package: " + overall);
+            }
+            return true;
+        }
+    }
+
+    final class Goods{
+        boolean isReset;
+        AppCheckerInfo info;
+        int oldLevel;
+        int newLevel;
+        boolean bootStart;
+
+        public Goods(boolean isReset, AppCheckerInfo info, int oldLevel, int newLevel, boolean bootStart) {
+            this.isReset = isReset;
+            this.info = info;
+            this.oldLevel = oldLevel;
+            this.newLevel = newLevel;
+            this.bootStart = bootStart;
+        }
+    }
+
+}
+
Index: build/target/product/core.mk
===================================================================
--- build/target/product/core.mk	(revision 5726)
+++ build/target/product/core.mk	(revision 5734)
@@ -64,6 +64,7 @@
     simLock \
     ChromeCustomizations \
     ServiceMenu \
+    ProcessControl \
     Fingerprint
 
 $(call inherit-product, $(SRC_TARGET_DIR)/product/core_base.mk)
Index: packages/apps/ProcessControl/Android.mk
===================================================================
--- packages/apps/ProcessControl/Android.mk	(revision 0)
+++ packages/apps/ProcessControl/Android.mk	(revision 5734)
@@ -0,0 +1,22 @@
+
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MANIFEST_FILE := AndroidManifest.xml
+LOCAL_STATIC_JAVA_LIBRARIES := \
+    android-support-v4 
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SRC_FILES := $(call all-subdir-java-files)
+
+LOCAL_PACKAGE_NAME := ProcessControl
+
+LOCAL_CERTIFICATE := platform
+
+include $(BUILD_PACKAGE)
+
+
+
+
Index: packages/apps/ProcessControl/AndroidManifest.xml
===================================================================
--- packages/apps/ProcessControl/AndroidManifest.xml	(revision 0)
+++ packages/apps/ProcessControl/AndroidManifest.xml	(revision 5734)
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.topwise.processcontrol"
+    android:versionCode="1"
+    android:versionName="1.0" >
+
+    <uses-sdk android:minSdkVersion="20" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_app"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" 
+        >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+            android:name=".AppSettings"
+            android:label="@string/title_activity_appsettings" >
+        </activity>
+        <activity
+            android:name=".LevelTimeSetting"
+            android:label="@string/title_activity_set_level_time"
+            android:theme="@android:style/Theme.DeviceDefault.Dialog.NoActionBar.MinWidth">>
+        </activity>
+
+        <receiver android:name="ServiceMenuBroadcastReceiver" >
+            <intent-filter>
+                <action android:name="android.provider.Telephony.SECRET_CODE" />
+                <data
+                    android:host="4321"
+                    android:scheme="android_secret_code" />
+            </intent-filter>
+        </receiver>
+    </application>
+
+</manifest>
Index: packages/apps/ProcessControl/src/com/topwise/utils/SystemBarTintManager.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/utils/SystemBarTintManager.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/utils/SystemBarTintManager.java	(revision 5734)
@@ -0,0 +1,546 @@
+package com.topwise.utils;
+
+import android.annotation.SuppressLint;  
+import android.annotation.TargetApi;  
+import android.app.Activity;  
+import android.content.Context;  
+import android.content.res.Configuration;  
+import android.content.res.Resources;  
+import android.content.res.TypedArray;  
+import android.graphics.drawable.Drawable;  
+import android.os.Build;  
+import android.util.DisplayMetrics;  
+import android.util.TypedValue;  
+import android.view.Gravity;  
+import android.view.View;  
+import android.view.ViewConfiguration;  
+import android.view.ViewGroup;  
+import android.view.Window;  
+import android.view.WindowManager;  
+import android.widget.FrameLayout.LayoutParams;  
+ 
+import java.lang.reflect.Method;  
+/**  
+ * @author zhangyu
+ * Class to manage status and navigation bar tint effects when using KitKat   
+ * translucent system UI modes.  
+ *  
+ */  
+//
+public class SystemBarTintManager {  
+ 
+   static {  
+       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {  
+           try {  
+               Class c = Class.forName("android.os.SystemProperties");  
+               Method m = c.getDeclaredMethod("get", String.class);  
+               m.setAccessible(true);  
+               sNavBarOverride = (String) m.invoke(null, "qemu.hw.mainkeys");  
+           } catch (Throwable e) {  
+               sNavBarOverride = null;  
+           }  
+       }  
+   }  
+
+   /**  
+    * The default system bar tint color value.  
+    */  
+   public static final int DEFAULT_TINT_COLOR = 0x99000000;  
+ 
+   private static String sNavBarOverride;  
+ 
+   private final SystemBarConfig mConfig;  
+   private boolean mStatusBarAvailable;  
+   private boolean mNavBarAvailable;  
+   private boolean mStatusBarTintEnabled;  
+   private boolean mNavBarTintEnabled;  
+   private View mStatusBarTintView;  
+   private View mNavBarTintView;  
+ 
+   /**  
+    * Constructor. Call this in the host activity onCreate method after its  
+    * content view has been set. You should always create new instances when  
+    * the host activity is recreated.  
+    *  
+    * @param activity The host activity.  
+    */  
+   @TargetApi(19)  
+   public SystemBarTintManager(Activity activity) {  
+ 
+       Window win = activity.getWindow();  
+       ViewGroup decorViewGroup = (ViewGroup) win.getDecorView();  
+ 
+       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {  
+           // check theme attrs  
+           int[] attrs = {android.R.attr.windowTranslucentStatus,  
+                   android.R.attr.windowTranslucentNavigation};  
+           TypedArray a = activity.obtainStyledAttributes(attrs);  
+           try {  
+               mStatusBarAvailable = a.getBoolean(0, false);  
+               mNavBarAvailable = a.getBoolean(1, false);  
+           } finally {  
+               a.recycle();  
+           }  
+ 
+           // check window flags  
+           WindowManager.LayoutParams winParams = win.getAttributes();  
+           int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;  
+           if ((winParams.flags & bits) != 0) {  
+               mStatusBarAvailable = true;  
+           }  
+           bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;  
+           if ((winParams.flags & bits) != 0) {  
+               mNavBarAvailable = true;  
+           }  
+       }  
+ 
+       mConfig = new SystemBarConfig(activity, mStatusBarAvailable, mNavBarAvailable);  
+       // device might not have virtual navigation keys  
+       if (!mConfig.hasNavigtionBar()) {  
+           mNavBarAvailable = false;  
+       }  
+ 
+       if (mStatusBarAvailable) {  
+           setupStatusBarView(activity, decorViewGroup);  
+       }  
+       if (mNavBarAvailable) {  
+           setupNavBarView(activity, decorViewGroup);  
+       }  
+ 
+   }  
+ 
+   /**  
+    * Enable tinting of the system status bar.  
+    *  
+    * If the platform is running Jelly Bean or earlier, or translucent system  
+    * UI modes have not been enabled in either the theme or via window flags,  
+    * then this method does nothing.  
+    *  
+    * @param enabled True to enable tinting, false to disable it (default).  
+    */  
+   public void setStatusBarTintEnabled(boolean enabled) {  
+       mStatusBarTintEnabled = enabled;  
+       if (mStatusBarAvailable) {  
+           mStatusBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);  
+       }  
+   }  
+ 
+   /**  
+    * Enable tinting of the system navigation bar.  
+    *  
+    * If the platform does not have soft navigation keys, is running Jelly Bean  
+    * or earlier, or translucent system UI modes have not been enabled in either  
+    * the theme or via window flags, then this method does nothing.  
+    *  
+    * @param enabled True to enable tinting, false to disable it (default).  
+    */  
+   public void setNavigationBarTintEnabled(boolean enabled) {  
+       mNavBarTintEnabled = enabled;  
+       if (mNavBarAvailable) {  
+           mNavBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified color tint to all system UI bars.  
+    *  
+    * @param color The color of the background tint.  
+    */  
+   public void setTintColor(int color) {  
+       setStatusBarTintColor(color);  
+       setNavigationBarTintColor(color);  
+   }  
+ 
+   /**  
+    * Apply the specified drawable or color resource to all system UI bars.  
+    *  
+    * @param res The identifier of the resource.  
+    */  
+   public void setTintResource(int res) {  
+       setStatusBarTintResource(res);  
+       setNavigationBarTintResource(res);  
+   }  
+ 
+   /**  
+    * Apply the specified drawable to all system UI bars.  
+    *  
+    * @param drawable The drawable to use as the background, or null to remove it.  
+    */  
+   public void setTintDrawable(Drawable drawable) {  
+       setStatusBarTintDrawable(drawable);  
+       setNavigationBarTintDrawable(drawable);  
+   }  
+ 
+   /**  
+    * Apply the specified alpha to all system UI bars.  
+    *  
+    * @param alpha The alpha to use  
+    */  
+   public void setTintAlpha(float alpha) {  
+       setStatusBarAlpha(alpha);  
+       setNavigationBarAlpha(alpha);  
+   }  
+ 
+   /**  
+    * Apply the specified color tint to the system status bar.  
+    *  
+    * @param color The color of the background tint.  
+    */  
+   public void setStatusBarTintColor(int color) {  
+       if (mStatusBarAvailable) {  
+           mStatusBarTintView.setBackgroundColor(color);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified drawable or color resource to the system status bar.  
+    *  
+    * @param res The identifier of the resource.  
+    */  
+   public void setStatusBarTintResource(int res) {  
+       if (mStatusBarAvailable) {  
+           mStatusBarTintView.setBackgroundResource(res);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified drawable to the system status bar.  
+    *  
+    * @param drawable The drawable to use as the background, or null to remove it.  
+    */  
+   @SuppressWarnings("deprecation")  
+   public void setStatusBarTintDrawable(Drawable drawable) {  
+       if (mStatusBarAvailable) {  
+           mStatusBarTintView.setBackgroundDrawable(drawable);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified alpha to the system status bar.  
+    *  
+    * @param alpha The alpha to use  
+    */  
+   @TargetApi(11)  
+   public void setStatusBarAlpha(float alpha) {  
+       if (mStatusBarAvailable && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {  
+           mStatusBarTintView.setAlpha(alpha);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified color tint to the system navigation bar.  
+    *  
+    * @param color The color of the background tint.  
+    */  
+   public void setNavigationBarTintColor(int color) {  
+       if (mNavBarAvailable) {  
+           mNavBarTintView.setBackgroundColor(color);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified drawable or color resource to the system navigation bar.  
+    *  
+    * @param res The identifier of the resource.  
+    */  
+   public void setNavigationBarTintResource(int res) {  
+       if (mNavBarAvailable) {  
+           mNavBarTintView.setBackgroundResource(res);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified drawable to the system navigation bar.  
+    *  
+    * @param drawable The drawable to use as the background, or null to remove it.  
+    */  
+   @SuppressWarnings("deprecation")  
+   public void setNavigationBarTintDrawable(Drawable drawable) {  
+       if (mNavBarAvailable) {  
+           mNavBarTintView.setBackgroundDrawable(drawable);  
+       }  
+   }  
+ 
+   /**  
+    * Apply the specified alpha to the system navigation bar.  
+    *  
+    * @param alpha The alpha to use  
+    */  
+   @TargetApi(11)  
+   public void setNavigationBarAlpha(float alpha) {  
+       if (mNavBarAvailable && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {  
+           mNavBarTintView.setAlpha(alpha);  
+       }  
+   }  
+ 
+   /**  
+    * Get the system bar configuration.  
+    *  
+    * @return The system bar configuration for the current device configuration.  
+    */  
+   public SystemBarConfig getConfig() {  
+       return mConfig;  
+   }  
+ 
+   /**  
+    * Is tinting enabled for the system status bar?  
+    *  
+    * @return True if enabled, False otherwise.  
+    */  
+   public boolean isStatusBarTintEnabled() {  
+       return mStatusBarTintEnabled;  
+   }  
+ 
+   /**  
+    * Is tinting enabled for the system navigation bar?  
+    *  
+    * @return True if enabled, False otherwise.  
+    */  
+   public boolean isNavBarTintEnabled() {  
+       return mNavBarTintEnabled;  
+   }  
+ 
+   private void setupStatusBarView(Context context, ViewGroup decorViewGroup) {  
+       mStatusBarTintView = new View(context);  
+       LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getStatusBarHeight());  
+       params.gravity = Gravity.TOP;  
+       if (mNavBarAvailable && !mConfig.isNavigationAtBottom()) {  
+           params.rightMargin = mConfig.getNavigationBarWidth();  
+       }  
+       mStatusBarTintView.setLayoutParams(params);  
+       mStatusBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);  
+       mStatusBarTintView.setVisibility(View.GONE);  
+       decorViewGroup.addView(mStatusBarTintView);  
+   }  
+ 
+   private void setupNavBarView(Context context, ViewGroup decorViewGroup) {  
+       mNavBarTintView = new View(context);  
+       LayoutParams params;  
+       if (mConfig.isNavigationAtBottom()) {  
+           params = new LayoutParams(LayoutParams.MATCH_PARENT, mConfig.getNavigationBarHeight());  
+           params.gravity = Gravity.BOTTOM;  
+       } else {  
+           params = new LayoutParams(mConfig.getNavigationBarWidth(), LayoutParams.MATCH_PARENT);  
+           params.gravity = Gravity.RIGHT;  
+       }  
+       mNavBarTintView.setLayoutParams(params);  
+       mNavBarTintView.setBackgroundColor(DEFAULT_TINT_COLOR);  
+       mNavBarTintView.setVisibility(View.GONE);  
+       decorViewGroup.addView(mNavBarTintView);  
+   }  
+ 
+   /**  
+    * Class which describes system bar sizing and other characteristics for the current  
+    * device configuration.  
+    *  
+    */  
+   public static class SystemBarConfig {  
+ 
+       private static final String STATUS_BAR_HEIGHT_RES_NAME = "status_bar_height";  
+       private static final String NAV_BAR_HEIGHT_RES_NAME = "navigation_bar_height";  
+       private static final String NAV_BAR_HEIGHT_LANDSCAPE_RES_NAME = "navigation_bar_height_landscape";  
+       private static final String NAV_BAR_WIDTH_RES_NAME = "navigation_bar_width";  
+       private static final String SHOW_NAV_BAR_RES_NAME = "config_showNavigationBar";  
+ 
+       private final boolean mTranslucentStatusBar;  
+       private final boolean mTranslucentNavBar;  
+       private final int mStatusBarHeight;  
+       private final int mActionBarHeight;  
+       private final boolean mHasNavigationBar;  
+       private final int mNavigationBarHeight;  
+       private final int mNavigationBarWidth;  
+       private final boolean mInPortrait;  
+       private final float mSmallestWidthDp;  
+ 
+       private SystemBarConfig(Activity activity, boolean translucentStatusBar, boolean traslucentNavBar) {  
+           Resources res = activity.getResources();  
+           mInPortrait = (res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT);  
+           mSmallestWidthDp = getSmallestWidthDp(activity);  
+           mStatusBarHeight = getInternalDimensionSize(res, STATUS_BAR_HEIGHT_RES_NAME);  
+           mActionBarHeight = getActionBarHeight(activity);  
+           mNavigationBarHeight = getNavigationBarHeight(activity);  
+           mNavigationBarWidth = getNavigationBarWidth(activity);  
+           mHasNavigationBar = (mNavigationBarHeight > 0);  
+           mTranslucentStatusBar = translucentStatusBar;  
+           mTranslucentNavBar = traslucentNavBar;  
+       }  
+ 
+       @TargetApi(14)  
+       private int getActionBarHeight(Context context) {  
+           int result = 0;  
+           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {  
+               TypedValue tv = new TypedValue();  
+               context.getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true);  
+               result = TypedValue.complexToDimensionPixelSize(tv.data, context.getResources().getDisplayMetrics());  
+           }  
+           return result;  
+       }  
+ 
+       @TargetApi(14)  
+       private int getNavigationBarHeight(Context context) {  
+           Resources res = context.getResources();  
+           int result = 0;  
+           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {  
+               if (hasNavBar(context)) {  
+                   String key;  
+                   if (mInPortrait) {  
+                       key = NAV_BAR_HEIGHT_RES_NAME;  
+                   } else {  
+                       key = NAV_BAR_HEIGHT_LANDSCAPE_RES_NAME;  
+                   }  
+                   return getInternalDimensionSize(res, key);  
+               }  
+           }  
+           return result;  
+       }  
+ 
+       @TargetApi(14)  
+       private int getNavigationBarWidth(Context context) {  
+           Resources res = context.getResources();  
+           int result = 0;  
+           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {  
+               if (hasNavBar(context)) {  
+                   return getInternalDimensionSize(res, NAV_BAR_WIDTH_RES_NAME);  
+               }  
+           }  
+           return result;  
+       }  
+ 
+       @TargetApi(14)  
+       private boolean hasNavBar(Context context) {  
+           Resources res = context.getResources();  
+           int resourceId = res.getIdentifier(SHOW_NAV_BAR_RES_NAME, "bool", "android");  
+           if (resourceId != 0) {  
+               boolean hasNav = res.getBoolean(resourceId);  
+               // check override flag (see static block)  
+               if ("1".equals(sNavBarOverride)) {  
+                   hasNav = false;  
+               } else if ("0".equals(sNavBarOverride)) {  
+                   hasNav = true;  
+               }  
+               return hasNav;  
+           } else { // fallback  
+               return !ViewConfiguration.get(context).hasPermanentMenuKey();  
+           }  
+       }  
+ 
+       private int getInternalDimensionSize(Resources res, String key) {  
+           int result = 0;  
+           int resourceId = res.getIdentifier(key, "dimen", "android");  
+           if (resourceId > 0) {  
+               result = res.getDimensionPixelSize(resourceId);  
+           }  
+           return result;  
+       }  
+ 
+       @SuppressLint("NewApi")  
+       private float getSmallestWidthDp(Activity activity) {  
+           DisplayMetrics metrics = new DisplayMetrics();  
+           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {  
+               activity.getWindowManager().getDefaultDisplay().getRealMetrics(metrics);  
+           } else {  
+               // TODO this is not correct, but we don't really care pre-kitkat  
+               activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);  
+           }  
+           float widthDp = metrics.widthPixels / metrics.density;  
+           float heightDp = metrics.heightPixels / metrics.density;  
+           return Math.min(widthDp, heightDp);  
+       }  
+ 
+       /**  
+        * Should a navigation bar appear at the bottom of the screen in the current  
+        * device configuration? A navigation bar may appear on the right side of  
+        * the screen in certain configurations.  
+        *  
+        * @return True if navigation should appear at the bottom of the screen, False otherwise.  
+        */  
+       public boolean isNavigationAtBottom() {  
+           return (mSmallestWidthDp >= 600 || mInPortrait);  
+       }  
+ 
+       /**  
+        * Get the height of the system status bar.  
+        *  
+        * @return The height of the status bar (in pixels).  
+        */  
+       public int getStatusBarHeight() {  
+           return mStatusBarHeight;  
+       }  
+ 
+       /**  
+        * Get the height of the action bar.  
+        *  
+        * @return The height of the action bar (in pixels).  
+        */  
+       public int getActionBarHeight() {  
+           return mActionBarHeight;  
+       }  
+ 
+       /**  
+        * Does this device have a system navigation bar?  
+        *  
+        * @return True if this device uses soft key navigation, False otherwise.  
+        */  
+       public boolean hasNavigtionBar() {  
+           return mHasNavigationBar;  
+       }  
+ 
+       /**  
+        * Get the height of the system navigation bar.  
+        *  
+        * @return The height of the navigation bar (in pixels). If the device does not have  
+        * soft navigation keys, this will always return 0.  
+        */  
+       public int getNavigationBarHeight() {  
+           return mNavigationBarHeight;  
+       }  
+ 
+       /**  
+        * Get the width of the system navigation bar when it is placed vertically on the screen.  
+        *  
+        * @return The width of the navigation bar (in pixels). If the device does not have  
+        * soft navigation keys, this will always return 0.  
+        */  
+       public int getNavigationBarWidth() {  
+           return mNavigationBarWidth;  
+       }  
+ 
+       /**  
+        * Get the layout inset for any system UI that appears at the top of the screen.  
+        *  
+        * @param withActionBar True to include the height of the action bar, False otherwise.  
+        * @return The layout inset (in pixels).  
+        */  
+       public int getPixelInsetTop(boolean withActionBar) {  
+           return (mTranslucentStatusBar ? mStatusBarHeight : 0) + (withActionBar ? mActionBarHeight : 0);  
+       }  
+ 
+       /**  
+        * Get the layout inset for any system UI that appears at the bottom of the screen.  
+        *  
+        * @return The layout inset (in pixels).  
+        */  
+       public int getPixelInsetBottom() {  
+           if (mTranslucentNavBar && isNavigationAtBottom()) {  
+               return mNavigationBarHeight;  
+           } else {  
+               return 0;  
+           }  
+       }  
+ 
+       /**  
+        * Get the layout inset for any system UI that appears at the right of the screen.  
+        *  
+        * @return The layout inset (in pixels).  
+        */  
+       public int getPixelInsetRight() {  
+           if (mTranslucentNavBar && !isNavigationAtBottom()) {  
+               return mNavigationBarWidth;  
+           } else {  
+               return 0;  
+           }  
+       }  
+ 
+   }  
+ 
+} 
Index: packages/apps/ProcessControl/src/com/topwise/utils/MyPagerAdapter.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/utils/MyPagerAdapter.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/utils/MyPagerAdapter.java	(revision 5734)
@@ -0,0 +1,44 @@
+package com.topwise.utils;
+
+import java.util.List;
+
+import android.support.v4.view.PagerAdapter;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+
+/**
+ *@author zhangyu
+ */
+public class MyPagerAdapter  extends PagerAdapter{
+    private String TAG = "ProcessControl/MyPagerAdapter";
+
+    //
+    public List<View> mListViews;
+
+    public MyPagerAdapter(List<View> mListViews) {
+         this.mListViews = mListViews;
+    }
+
+    @Override  
+    public void destroyItem(ViewGroup container, int position,Object object) {  
+        Log.d(TAG,"destroyItem"+position);
+        container.removeView(mListViews.get(position));  
+    }  
+    
+    public int getCount() {
+        return mListViews.size();
+    }
+
+    public Object instantiateItem(ViewGroup container, int position) {  
+        View view = mListViews.get(position);  
+        container.addView(view);  
+        Log.d(TAG,"instantiateItem"+position);
+        return view;  
+    }  
+    
+    public boolean isViewFromObject(View arg0, Object arg1) {
+        return arg0 == (arg1);
+    }
+}
+
Index: packages/apps/ProcessControl/src/com/topwise/utils/UIHelper.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/utils/UIHelper.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/utils/UIHelper.java	(revision 5734)
@@ -0,0 +1,52 @@
+package com.topwise.utils;
+
+import android.app.Activity;
+import android.os.Build;
+import android.annotation.TargetApi;
+import android.view.Window;
+import android.view.WindowManager;
+
+//import com.readystatesoftware.systembartint.SystemBarTintManager;
+//
+/**
+ *@author zhangyu
+ */
+public class UIHelper {
+    private static UIHelper mUIHelper = null;
+    private Activity mActivity;
+	private UIHelper() {
+		super();
+	}
+
+	public static synchronized UIHelper getInstance() {
+		if (mUIHelper == null) {
+			mUIHelper = new UIHelper();
+		}
+		return mUIHelper;
+	}
+
+	public void setSystemBar(Activity activity,int colorId) {
+		mActivity = activity;
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+			setTranslucentStatus(true);
+		}
+		SystemBarTintManager manager = new SystemBarTintManager(activity);
+		manager.setStatusBarTintEnabled(true);
+		manager.setStatusBarTintResource(colorId);
+	
+	}
+
+	@TargetApi(Build.VERSION_CODES.KITKAT)
+	private void setTranslucentStatus(boolean is) {
+		Window window = mActivity.getWindow();
+		WindowManager.LayoutParams params = window.getAttributes();
+		final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
+		if (is) {
+			params.flags |= bits;
+		} else {
+			params.flags &= ~bits;
+		}
+		window.setAttributes(params);
+	}
+
+}
Index: packages/apps/ProcessControl/src/com/topwise/utils/ItemAdapter.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/utils/ItemAdapter.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/utils/ItemAdapter.java	(revision 5734)
@@ -0,0 +1,116 @@
+package com.topwise.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.topwise.data.Application;
+import com.topwise.processcontrol.R;
+
+import android.content.Context;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+/**
+ *@author zhangyu
+ */
+public class ItemAdapter extends BaseAdapter{
+    private  final static  String TAG = "ProcessControl/ItemAdapter";
+    //List
+    private ArrayList<Application> mList;
+    private int mLayoutId;
+    private LayoutInflater mInflater;
+    private Context mContext;
+    //
+    public ItemAdapter(Context context, List<Application> list,int Grade, int resource)
+    {
+        mList = new ArrayList<Application> ();
+        setGradeApplications(list,Grade);
+        mLayoutId = resource;
+        mContext = context;
+        mInflater = LayoutInflater.from(context);
+        Log.d(TAG,"getCount "+ mList.size());
+    }
+    //
+    public void changeData(List<Application> list) {
+        mList = (ArrayList<Application>) list;
+    }
+    //
+    public int getCount() {
+        if(mList == null){
+             return 0;
+        }
+        return mList.size();
+    }
+
+    //item
+    public Application getItem(int position) {
+        if(mList == null){
+             return null;
+        }
+        return mList.get(position);
+    } 
+
+    //ItenId
+    public long getItemId(int position) {
+         if (mList == null) {
+              return 0;
+         }
+         return mList.get(position).getmApplicationId();
+    }
+
+    //View
+    public View getView(int position, View convertView, ViewGroup parent) {
+		//View
+//        if (mList == null) {
+//            return null;
+//        }
+        ViewHolder viewHolder = null;
+        if(convertView == null) {
+            viewHolder = new ViewHolder();
+            convertView = mInflater.inflate(mLayoutId,parent, false);
+            viewHolder.imgView = (ImageView) convertView.findViewById(R.id.item_image);
+            viewHolder.tvTile = (TextView) convertView.findViewById(R.id.item_title);
+            viewHolder.tvViewDecs = (TextView) convertView.findViewById(R.id.item_textdesc);
+           //
+            convertView.setTag(viewHolder);
+        } else {
+            viewHolder = (ViewHolder) convertView.getTag();
+        }
+        Application application = mList.get(position);
+        viewHolder.imgView.setBackground(application.getmDrawable());
+        viewHolder.tvTile.setText(application.getmApplicationName());
+        //App 
+        if(application.getmApplicationDescFlag())
+        {
+        	viewHolder.tvViewDecs.setText(mContext.getResources().getString(R.string.appsettingspreference_open_forbid_start));
+        }else {
+        	viewHolder.tvViewDecs.setText(" ");
+		}
+		return convertView;
+	}
+
+	//GradeApplicationmList
+	public void setGradeApplications(List<Application> list,int Grade){
+            if(list!=null){
+                //Log.d(TAG,""+list.size()+"  "+Grade);
+                for(int i = 0 ;i <list.size();i ++){
+                    Application application = list.get(i);
+                    if(Grade == application.getAppSurvivalGrade()){
+                        mList.add(application);
+                    }
+                 }
+             }
+	 }
+
+	 class ViewHolder {
+             ImageView imgView ;
+             TextView tvTile ;
+             TextView tvViewDecs ;
+         }
+}
+
Index: packages/apps/ProcessControl/src/com/topwise/utils/PkgManegerTools.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/utils/PkgManegerTools.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/utils/PkgManegerTools.java	(revision 5734)
@@ -0,0 +1,112 @@
+package com.topwise.utils;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import com.topwise.data.Application;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.graphics.drawable.Drawable;
+import com.topwise.processcontrol.R;
+import android.util.Log;
+//
+import com.topwise.appcheck.*;
+
+/**
+ *@author zhangyu
+ */
+public class PkgManegerTools {
+    private String TAG = "TabFragment/PkgManegerTools";
+    //PackageManager 
+    private PackageManager pm;
+    //List
+    private List<AppCheckerInfo> mAppCheckerInfoList;
+    //AppLication List
+    private ArrayList<Application> mlist;
+    //
+    private Context mContext;
+    //App Grade
+    private int mGrade;
+    //AppChecker
+    private AppCheckerManager manager;
+    public PkgManegerTools(List<AppCheckerInfo> AppCheckerInfoList,Context context,int Grade) {
+        this.mAppCheckerInfoList = AppCheckerInfoList;
+        this.mContext = context;
+        this.mGrade = Grade;
+        this.mlist = new ArrayList<Application>();
+        //
+        this.manager = AppCheckerManager.getInstance();
+    }
+
+    public ArrayList<Application> getAllApplication(){
+        //mlist
+        mlist.clear();
+        if(mAppCheckerInfoList.size() == 0){  
+            //    ArrayList<Application> mlist
+            //mlist.add(new Application(mContext.getResources().getDrawable(R.drawable.ic_default),"",""+mGrade+"",false,mGrade));
+            Log.d(TAG,""+mAppCheckerInfoList.size());
+            return null;
+        }
+        //
+        pm = mContext.getPackageManager();  
+        //   
+        List<ApplicationInfo> listAppcations = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);  
+        //  
+        Collections.sort(listAppcations,new ApplicationInfo.DisplayNameComparator(pm));
+        //
+        for(AppCheckerInfo appCheckerInfo : mAppCheckerInfoList){
+            //Log.d(TAG,pkgname);
+            //->Application
+            for (ApplicationInfo app : listAppcations) {
+            if((appCheckerInfo.packageName).equals(app.packageName)){
+                mlist.add(new Application(app.loadIcon(pm),app.packageName,(String) app.loadLabel(pm),appCheckerInfo.isBootKill(),appCheckerInfo.level));
+            }                
+        }
+    }
+    return mlist;            
+}
+    // 
+    public  boolean ifAutoBoot(AppCheckerInfo appCheckerInfo){
+        
+        return appCheckerInfo.isBootKill();
+    }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: packages/apps/ProcessControl/src/com/topwise/data/Application.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/data/Application.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/data/Application.java	(revision 5734)
@@ -0,0 +1,90 @@
+package com.topwise.data;
+
+import android.graphics.drawable.Drawable;
+
+/**
+ * @author zhangyu
+ * 
+ * ListViewDrawable ApplicationName ApplicationDesc 
+ * 
+*/
+public class Application {
+    //
+    //AppLogo
+    private Drawable mDrawable;
+    //App
+    private String mPkgName;
+    //App 
+    private String mApplicationName;
+    //App 
+    private String mApplicationDesc = "";
+    //App
+    private Boolean mApplicationDescFlag = false;
+    //App ID
+    private long mApplicationId;
+    //AppGrade 1 2 3 4 5 
+    private int  appSurvivalGrade;
+
+    //
+    public Application(Drawable drawable,String PkgName , String ApplicationName,Boolean ApplicationDescFlag,int  grade){
+        this.mDrawable  = drawable;
+        this.mPkgName = PkgName;
+        this.mApplicationName = ApplicationName;
+        this.mApplicationDescFlag = ApplicationDescFlag;
+        this.setAppSurvivalGrade(grade);
+    }
+
+    public String getmPkgName() {
+        return mPkgName;
+    }
+
+    public void setmPkgName(String mPkgName) {
+        this.mPkgName = mPkgName;
+    }
+
+    public Boolean getmApplicationDescFlag() {
+        return mApplicationDescFlag;
+    }
+
+    public void setmApplicationDescFlag(Boolean mApplicationDescFlag) {
+        this.mApplicationDescFlag = mApplicationDescFlag;
+    }
+
+    public Drawable getmDrawable() {
+        return mDrawable;
+    }
+    public void setmDrawable(Drawable mDrawable) {
+        this.mDrawable = mDrawable;
+    }
+    public String getmApplicationName() {
+        return mApplicationName;
+    }
+    public void setmApplicationName(String mApplicationName) {
+        this.mApplicationName = mApplicationName;
+    }
+
+    public long getmApplicationId() {
+        mApplicationId = mPkgName.hashCode();
+        return mApplicationId;
+    }
+    public void setmApplicationId(long mApplicationId) {
+        this.mApplicationId = mApplicationId;
+    }
+	
+    public int getAppSurvivalGrade() {
+        return appSurvivalGrade;
+    }
+
+    public void setAppSurvivalGrade(int appSurvivalGrade) {
+        this.appSurvivalGrade = appSurvivalGrade;
+    }
+
+    public class AppGrade{ 
+        public static final int APP_SURVIVAL_GRADE_ONE = 1;
+        public static final int APP_SURVIVAL_GRADE_TWO = 2;
+        public static final int APP_SURVIVAL_GRADE_THREE = 3;
+        public static final int APP_SURVIVAL_GRADE_FOUR = 4;
+        public static final int APP_SURVIVAL_GRADE_FIVE = 5;
+    }	
+}
+
Index: packages/apps/ProcessControl/src/com/topwise/processcontrol/AppSettings.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/processcontrol/AppSettings.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/processcontrol/AppSettings.java	(revision 5734)
@@ -0,0 +1,316 @@
+package com.topwise.processcontrol;
+
+import android.app.ActionBar;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.TextView;
+//
+import com.topwise.appcheck.*;
+
+import com.topwise.utils.UIHelper;
+
+/**
+ *@author zhangyu
+ */
+public class AppSettings extends PreferenceActivity  implements Preference.OnPreferenceClickListener{
+    private  final static  String TAG = "TabFragment/AppSettings";
+    private ActionBar actionBar;
+    private TextView tvTitle;
+    //
+    private AppCheckerManager manager;
+    private CheckBoxPreference appSettings_openManaerPreference;       //  
+    private CheckBoxPreference appSettings_gradeOnePreference;         // 1  
+    private CheckBoxPreference appSettings_gradeTwoPreference;         // 2  
+    private CheckBoxPreference appSettings_gradeThreePreference;       // 3  
+    private CheckBoxPreference appSettings_gradeFourPreference;        // 4  
+    private CheckBoxPreference appSettings_gradeFivePreference;        // 5
+   
+    //app
+    private  int  mAppSurvivalGrade ;   //AppGrade
+    private String mApplicationName; 
+    private String mApplicationPkgName;      
+    private Boolean mApplicationDescFlag; 
+    private long  mApplicationId;
+
+   
+    @SuppressWarnings("deprecation")
+    protected void onCreate(Bundle savedInstanceState) {
+        Log.d(TAG,"onCreate");
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.appsettingspreference);
+        //
+        //UIHelper.getInstance().setSystemBar(AppSettings.this,R.color.state_background);
+
+        //Tab
+        actionBar = getActionBar();
+        actionBar.setDisplayHomeAsUpEnabled(true);
+        actionBar.setHomeButtonEnabled(true);		
+		
+        //
+        initData();
+        //actionBar.setTitle(getIntent().getExtras().getString("test","ZhangyuApp")+" "+getIntent().getExtras().getInt("position"));
+        setTitleCenter(getIntent().getExtras().getString("ApplicationName","TestApp"));
+        //key
+        appSettings_openManaerPreference = (CheckBoxPreference) findPreference("open_forbid_start");
+        appSettings_gradeOnePreference = (CheckBoxPreference) findPreference("grade_one");
+        appSettings_gradeTwoPreference = (CheckBoxPreference) findPreference("grade_two");
+        appSettings_gradeThreePreference = (CheckBoxPreference) findPreference("grade_three");
+        appSettings_gradeFourPreference = (CheckBoxPreference) findPreference("grade_four");
+        appSettings_gradeFivePreference = (CheckBoxPreference) findPreference("grade_five");
+        //   
+        appSettings_openManaerPreference.setOnPreferenceClickListener(this);
+        appSettings_gradeOnePreference.setOnPreferenceClickListener(this);
+        appSettings_gradeTwoPreference.setOnPreferenceClickListener(this);
+        appSettings_gradeThreePreference.setOnPreferenceClickListener(this);
+        appSettings_gradeFourPreference.setOnPreferenceClickListener(this);
+        appSettings_gradeFivePreference.setOnPreferenceClickListener(this);
+		
+        //Grade ApplicationDescFlag
+        setOtherCheckBoxPreferenceAllFalse(mAppSurvivalGrade);
+        appSettings_openManaerPreference.setChecked(mApplicationDescFlag);
+        
+        //
+        initGrade();
+    }
+    private void initGrade(){
+        appSettings_gradeOnePreference.setTitle(getResources().getString(R.string.appsettingspreference_grade,getGradeNumByGrade(AppCheckerManager.SHORT_LEVEL),getGradeDesByGrade(AppCheckerManager.SHORT_LEVEL)));
+        appSettings_gradeTwoPreference.setTitle(getResources().getString(R.string.appsettingspreference_grade,getGradeNumByGrade(AppCheckerManager.MEDIUM_LEVEL),getGradeDesByGrade(AppCheckerManager.MEDIUM_LEVEL)));
+        appSettings_gradeThreePreference.setTitle(getResources().getString(R.string.appsettingspreference_grade,getGradeNumByGrade(AppCheckerManager.LONG_LEVEL),getGradeDesByGrade(AppCheckerManager.LONG_LEVEL)));
+        appSettings_gradeFourPreference.setTitle(getResources().getString(R.string.appsettingspreference_grade,getGradeNumByGrade(AppCheckerManager.SUPERLONG_LEVEL),getGradeDesByGrade(AppCheckerManager.SUPERLONG_LEVEL)));
+    }
+    //int
+    private int getGradeNumByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return num;
+           else if(num>=60&&num<=60*24)  return num/60;
+           else return num/60;
+    }
+    //int
+    private String getGradeDesByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return getResources().getString(R.string.unit_min);
+           else if(num == 60) return getResources().getString(R.string.unit_hour);
+           else return getResources().getString(R.string.unit_hours);
+     }
+
+
+	
+    public void initData(){	
+        //
+        manager = AppCheckerManager.getInstance(); 
+        //
+        mAppSurvivalGrade  = getIntent().getExtras().getInt("AppSurvivalGrade");
+        mApplicationName = getIntent().getExtras().getString("ApplicationName");
+        mApplicationPkgName = getIntent().getExtras().getString("ApplicationPkgName");
+        mApplicationDescFlag = getIntent().getExtras().getBoolean("ApplicationDescFlag");
+        mApplicationId  = getIntent().getExtras().getLong("ApplicationId");
+        Log.d(TAG,mAppSurvivalGrade+" "+mApplicationName+" "+mApplicationDescFlag+" "+mApplicationId+" "+mApplicationPkgName);
+    }
+    //Title
+    public void setTitleCenter(String title){
+        //
+        actionBar.setDisplayShowHomeEnabled(false);
+        int titleId = Resources.getSystem().getIdentifier("action_bar_title","id", "android");
+        tvTitle = (TextView) findViewById(titleId);
+        tvTitle.setTextColor(0xF0F0FFFF);
+        tvTitle.setTextSize(25);
+        //
+        DisplayMetrics metric = new DisplayMetrics();
+        getWindowManager().getDefaultDisplay().getMetrics(metric);
+        float density = metric.density;
+        int widthMax = metric.widthPixels;
+
+        //
+        tvTitle.setWidth(widthMax);
+
+        //padding
+        int paddingLeft = (int) (-16 * density);    // 
+        int paddingRight = (int) (-60 * density);   // 
+        tvTitle.setPadding(paddingLeft, 0, paddingRight, 0);
+
+        //paddingpadding
+        tvTitle.setGravity(Gravity.CENTER);
+        actionBar.setTitle(title);
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        Log.d(TAG,"onCreateOptionsMenu");
+        //Inflate the menu; this adds items to the action bar if it is present.
+        getMenuInflater().inflate(R.menu.appsettings, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+         Log.d(TAG,"onOptionsItemSelected");
+         if(item.isCheckable()){
+              item.setChecked(true);
+         }
+		
+         switch (item.getItemId()) {
+             case android.R.id.home:
+                  //App
+                  Intent intent = getIntent();
+                  intent.putExtra("AppSurvivalGrade", mAppSurvivalGrade);
+                  intent.putExtra("ApplicationDescFlag", mApplicationDescFlag);
+                  intent.putExtra("ApplicationId", mApplicationId);  //app
+			
+                  Log.d(TAG,"setResult  "+mAppSurvivalGrade+"  "+mApplicationDescFlag+"  "+mApplicationId);
+                  setResult(2, intent);
+                  finish();
+                  break;
+             case R.id.action_settings:
+                  break;
+             default:
+                  break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    //Preference
+    public boolean onPreferenceClick(Preference preference) {
+        Log.d(TAG,"onPreferenceClick");
+        //
+        if(preference.getKey().equals("open_forbid_start")){
+            Log.d(TAG,"  "+appSettings_openManaerPreference.getKey());
+            mApplicationDescFlag = appSettings_openManaerPreference.isChecked();
+            Log.d(TAG,"  "+mApplicationDescFlag+" "+mApplicationPkgName);
+            //
+            manager.setAutoBootEnabled(mApplicationPkgName,mApplicationDescFlag);
+        }
+     	else if(preference.getKey().equals("grade_one"))
+     	{
+            Log.d(TAG,"1   "+appSettings_gradeOnePreference.getKey());
+            //
+            setOtherCheckBoxPreferenceAllFalse(appSettings_gradeOnePreference);
+            //
+            mAppSurvivalGrade = 1;
+            Log.d(TAG,"1   "+mAppSurvivalGrade+" "+mApplicationPkgName);
+            manager.setLevel(mApplicationPkgName,mAppSurvivalGrade);
+     	}
+     	else if(preference.getKey().equals("grade_two"))
+     	{
+            Log.d(TAG,"2   "+appSettings_gradeTwoPreference.getKey());
+            setOtherCheckBoxPreferenceAllFalse(appSettings_gradeTwoPreference);
+            mAppSurvivalGrade = 2;
+            Log.d(TAG,"2   "+mAppSurvivalGrade+" "+mApplicationPkgName);
+            manager.setLevel(mApplicationPkgName,mAppSurvivalGrade);
+     	}
+     	else if(preference.getKey().equals("grade_three"))
+     	{
+            Log.d(TAG,"3   "+appSettings_gradeThreePreference.getKey()); 
+            setOtherCheckBoxPreferenceAllFalse(appSettings_gradeThreePreference);
+            mAppSurvivalGrade = 3;
+            Log.d(TAG,"3   "+mAppSurvivalGrade+" "+mApplicationPkgName);
+            manager.setLevel(mApplicationPkgName,mAppSurvivalGrade);
+     	}
+     	else if(preference.getKey().equals("grade_four"))
+     	{
+            Log.d(TAG,"4   "+appSettings_gradeFourPreference.getKey());
+            setOtherCheckBoxPreferenceAllFalse(appSettings_gradeFourPreference);
+            mAppSurvivalGrade = 4;
+            Log.d(TAG,"4   "+mAppSurvivalGrade+" "+mApplicationPkgName);
+            manager.setLevel(mApplicationPkgName,mAppSurvivalGrade);
+     	}
+     	else if(preference.getKey().equals("grade_five"))
+     	{
+            Log.d(TAG,"5   "+appSettings_gradeFivePreference.getKey());
+            setOtherCheckBoxPreferenceAllFalse(appSettings_gradeFivePreference);
+            mAppSurvivalGrade = 5;
+            Log.d(TAG,"5   "+mAppSurvivalGrade+" "+mApplicationPkgName);
+            manager.setLevel(mApplicationPkgName,mAppSurvivalGrade);
+     	}
+        return false;
+    }
+    //CheckBoxPreferencefalse By preference
+    public void setOtherCheckBoxPreferenceAllFalse(Preference preference){
+        if(preference.getKey().equals("grade_one"))
+        {
+            appSettings_gradeOnePreference.setChecked(true);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(preference.getKey().equals("grade_two")){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(true);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(preference.getKey().equals("grade_three")){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(true);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(preference.getKey().equals("grade_four")){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(true);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(preference.getKey().equals("grade_five")){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(true);
+        }
+    }
+	
+    //CheckBoxPreferencefalse By Grade
+    public void setOtherCheckBoxPreferenceAllFalse(int Grade){
+        Log.d(TAG,"setOtherCheckBoxPreferenceAllFalse "+Grade);
+        if(Grade == 1)
+        {
+            appSettings_gradeOnePreference.setChecked(true);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(Grade == 2){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(true);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(Grade == 3){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(true);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(Grade == 4){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(true);
+            appSettings_gradeFivePreference.setChecked(false);
+        }
+        else if(Grade == 5){
+            appSettings_gradeOnePreference.setChecked(false);
+            appSettings_gradeTwoPreference.setChecked(false);
+            appSettings_gradeThreePreference.setChecked(false);
+            appSettings_gradeFourPreference.setChecked(false);
+            appSettings_gradeFivePreference.setChecked(true);
+        }
+    }
+}
+
Index: packages/apps/ProcessControl/src/com/topwise/processcontrol/MainActivity.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/processcontrol/MainActivity.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/processcontrol/MainActivity.java	(revision 5734)
@@ -0,0 +1,504 @@
+package com.topwise.processcontrol;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.topwise.data.Application;
+import com.topwise.data.Application.AppGrade;
+import com.topwise.utils.ItemAdapter;
+import com.topwise.utils.MyPagerAdapter;
+import com.topwise.utils.PkgManegerTools;
+import com.topwise.utils.UIHelper;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.support.v4.view.ViewPager;
+import android.support.v4.view.ViewPager.OnPageChangeListener;
+import android.util.Log;
+import android.util.DisplayMetrics;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.AdapterView;
+import android.widget.ImageButton;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+import android.widget.AdapterView.OnItemClickListener;
+
+import android.widget.Toast;
+import android.app.Dialog;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+
+//
+import com.topwise.appcheck.*;
+import android.os.RemoteException;
+
+/**
+ * @author zhangyu
+ */
+public class MainActivity extends Activity implements android.view.View.OnClickListener {
+    private String TAG = "TabFragment/MainActivity";
+    // 
+    private ActionBar actionBar; 
+    private TextView tvTitle;
+    private int redColor = Color.parseColor("#c32136"); // tab red
+    private int blackColor = Color.parseColor("#000000"); // tab black
+
+    private ViewPager mViewPager;// 
+    private MyPagerAdapter mPagerAdapter;// View
+
+    // View
+    private int mWhichView;
+    // List
+    private ArrayList<Application> mlist;
+    private ArrayList<Application> mlist_1;
+    private ArrayList<Application> mlist_2;
+    private ArrayList<Application> mlist_3;
+    private ArrayList<Application> mlist_4;
+    private ArrayList<Application> mlist_5;
+    private AppCheckerManager manager;
+    private IAppCheckStoreObserver deleteObserver = new IAppCheckStoreObserver.Stub() {
+        @Override
+        public void appStoreChange(boolean reset, AppCheckerInfo info,int oldLevel, int newLevel, boolean bootStart)throws RemoteException {
+            // 
+            Log.d(TAG, "------appStoreChange------");
+        }
+    };
+
+    // TextView 
+    private TextView mTextView_15;
+    private TextView mTextView_1;
+    private TextView mTextView_3;
+    private TextView mTextView_24;
+    private TextView mTextView_never;
+
+    // relativeLayout 
+    private RelativeLayout mRelativeLayout_15;
+    private RelativeLayout mRelativeLayout_1;
+    private RelativeLayout mRelativeLayout_3;
+    private RelativeLayout mRelativeLayout_24;
+    private RelativeLayout mRelativeLayout_never;
+
+    protected void onCreate(Bundle savedInstanceState) {	
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        // 
+        UIHelper.getInstance().setSystemBar(MainActivity.this,R.color.state_background);
+        actionBar = getActionBar();
+
+        // Title
+        setTitleCenter(getResources().getString(R.string.app_name));
+        // ActionBar
+        // actionBar.setBackgroundDrawable(getResources().getDrawable(R.drawable.actionbar_state));
+        //  view
+        initView();
+        // 
+        initList();
+        //  ViewPager
+        initViewPager();
+        //  
+        initEvent();
+        //tab
+        initTab();
+    }
+    public void initTab(){
+
+         //5tabInt        
+         mTextView_15.setText(getResources().getString(R.string.tab_item,getGradeNumByGrade(AppCheckerManager.SHORT_LEVEL),getGradeDesByGrade(AppCheckerManager.SHORT_LEVEL)));
+         mTextView_1.setText(getResources().getString(R.string.tab_item,getGradeNumByGrade(AppCheckerManager.MEDIUM_LEVEL),getGradeDesByGrade(AppCheckerManager.MEDIUM_LEVEL)));
+         mTextView_3.setText(getResources().getString(R.string.tab_item,getGradeNumByGrade(AppCheckerManager.LONG_LEVEL),getGradeDesByGrade(AppCheckerManager.LONG_LEVEL)));
+         mTextView_24.setText(getResources().getString(R.string.tab_item,getGradeNumByGrade(AppCheckerManager.SUPERLONG_LEVEL),getGradeDesByGrade(AppCheckerManager.SUPERLONG_LEVEL)));
+         //ly_tv_never.setText(getResources().getString(R.string.tab_item_never));
+    }
+    //int
+    private int getGradeNumByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return num;
+           else return num/60;
+           
+    }
+    //int
+    private String getGradeDesByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return getResources().getString(R.string.unit_m);
+           else return getResources().getString(R.string.unit_h);
+    }
+
+    // Title
+    public void setTitleCenter(String title) {
+        // 
+        actionBar.setDisplayShowHomeEnabled(false);
+        int titleId = Resources.getSystem().getIdentifier("action_bar_title","id", "android");
+        tvTitle = (TextView) findViewById(titleId);
+        tvTitle.setTextColor(0xffffffff);// Title
+        tvTitle.setTextSize(24);
+        // 
+        DisplayMetrics metric = new DisplayMetrics();
+        getWindowManager().getDefaultDisplay().getMetrics(metric);
+        float density = metric.density;
+        int widthMax = metric.widthPixels;
+
+        // 
+        tvTitle.setWidth(widthMax);
+
+        // padding
+        int paddingLeft = (int) (-16 * density); // 
+        int paddingRight = (int) (-60 * density); // 
+        tvTitle.setPadding(paddingLeft, 0, paddingRight, 0);
+
+        // paddingpadding
+        tvTitle.setGravity(Gravity.CENTER);
+        actionBar.setTitle(title);
+    }
+
+    // 
+    private void initView() {
+        // TextView 
+        mTextView_15 = (TextView) findViewById(R.id.tv_15);
+        mTextView_1 = (TextView) findViewById(R.id.tv_1);
+        mTextView_3 = (TextView) findViewById(R.id.tv_3);
+        mTextView_24 = (TextView) findViewById(R.id.tView_24);
+        mTextView_never = (TextView) findViewById(R.id.tv_never);
+
+       // RelativeLayout 
+       mRelativeLayout_15 = (RelativeLayout) findViewById(R.id.ly_tv_15);
+       mRelativeLayout_1 = (RelativeLayout) findViewById(R.id.ly_tv_1);
+       mRelativeLayout_3 = (RelativeLayout) findViewById(R.id.ly_tv_3);
+       mRelativeLayout_24 = (RelativeLayout) findViewById(R.id.ly_tv_24);
+       mRelativeLayout_never = (RelativeLayout) findViewById(R.id.ly_tv_never);
+
+       // PagerView 
+       mViewPager = (ViewPager) findViewById(R.id.id_viewpage);
+
+    }
+
+    // ViewPager
+    private void initViewPager() {
+        // List
+
+        // MyPagerAdapter
+        LayoutInflater mLayoutInflater = LayoutInflater.from(this);
+        View view1 = mLayoutInflater.inflate(R.layout.tab_list_demo, null);
+        View view2 = mLayoutInflater.inflate(R.layout.tab_list_demo, null);
+        View view3 = mLayoutInflater.inflate(R.layout.tab_list_demo, null);
+        View view4 = mLayoutInflater.inflate(R.layout.tab_list_demo, null);
+        View view5 = mLayoutInflater.inflate(R.layout.tab_list_demo, null);
+
+        // 
+        View view01 = createView(view1, 1);
+        View view02 = createView(view2, 2);
+        View view03 = createView(view3, 3);
+        View view04 = createView(view4, 4);
+        View view05 = createView(view5, 5);
+
+        List<View> views = new ArrayList<View>();
+        views.add(view01);
+        views.add(view02);
+        views.add(view03);
+        views.add(view04);
+        views.add(view05);
+
+        // mViews = new ArrayList<View>();// View
+        mPagerAdapter = new MyPagerAdapter(views);
+
+        // AdapterViewaPaPter
+        mViewPager.setAdapter(mPagerAdapter);
+
+        //  tab
+        setTabAllToBlack();
+        mTextView_15.setTextColor(redColor);
+
+    }
+
+    //  
+    private void initEvent() {
+        mRelativeLayout_15.setOnClickListener(this);
+        mRelativeLayout_1.setOnClickListener(this);
+        mRelativeLayout_3.setOnClickListener(this);
+        mRelativeLayout_24.setOnClickListener(this);
+        mRelativeLayout_never.setOnClickListener(this);
+        mViewPager.setOnPageChangeListener(new OnPageChangeListener() {
+        /**
+         * ViewPage
+         */
+        // 
+            public void onPageSelected(int position) {
+                // Log.d(TAG,"1  "+position);
+                int currentItem = mViewPager.getCurrentItem();
+                Log.d(TAG, "1  currentItem" + (currentItem + 1));
+                switch (position) {
+                    case 0:
+                         setTabAllToBlack();
+                         mTextView_15.setTextColor(redColor);
+                         break;
+                    case 1:
+                         setTabAllToBlack();
+                         mTextView_1.setTextColor(redColor);
+                         break;
+                    case 2:
+                         setTabAllToBlack();
+                         mTextView_3.setTextColor(redColor);
+                         break;
+                    case 3:
+                         setTabAllToBlack();
+                         mTextView_24.setTextColor(redColor);
+                         break;
+                    case 4:
+                         setTabAllToBlack();
+                         mTextView_never.setTextColor(redColor);
+                         break;
+                    default:
+                         break;
+                 }
+            }
+
+            // 
+            public void onPageScrolled(int positionStart, float arg1,int positionEnd) {
+                // Log.d(TAG,"2  "+positionStart+"   "+positionEnd);
+            }
+
+            @Override
+            public void onPageScrollStateChanged(int position) {
+                // Log.d(TAG,"3  "+position);
+            }
+       });
+
+    }
+
+    public void onClick(View view) {
+        switch (view.getId()) {
+        case R.id.ly_tv_15:
+             // ViewPager Id
+             mViewPager.setCurrentItem(0);
+             setTabAllToBlack();
+             mTextView_15.setTextColor(redColor);
+             break;
+        case R.id.ly_tv_1:
+             mViewPager.setCurrentItem(1);
+             setTabAllToBlack();
+             mTextView_1.setTextColor(redColor);
+             break;
+        case R.id.ly_tv_3:
+             mViewPager.setCurrentItem(2);
+             setTabAllToBlack();
+             mTextView_3.setTextColor(redColor);
+             break;
+        case R.id.ly_tv_24:
+             mViewPager.setCurrentItem(3);
+             setTabAllToBlack();
+             mTextView_24.setTextColor(redColor);
+             break;
+        case R.id.ly_tv_never:
+             mViewPager.setCurrentItem(4);
+             setTabAllToBlack();
+             mTextView_never.setTextColor(redColor);
+             break;
+        default:
+             break;
+        }
+    }
+
+    private void setTabAllToBlack() {
+        mTextView_15.setTextColor(blackColor);
+        mTextView_1.setTextColor(blackColor);
+        mTextView_3.setTextColor(blackColor);
+        mTextView_24.setTextColor(blackColor);
+        mTextView_never.setTextColor(blackColor);
+    }
+
+    private View createView(View view, final int Grade) {
+        Log.d(TAG, "CreateFragment :" + Grade);
+
+        // TextView
+        TextView textView = (TextView) view.findViewById(R.id.item_desc);
+        textView.setGravity(Gravity.START);
+        // 
+        textView.setText("        " + getGradeDes(Grade));
+        textView.setTextSize(14);
+
+        // ListView
+        ListView listView = (ListView) view.findViewById(R.id.listView1);
+        // ItemAdapter
+        final ItemAdapter adapter = new ItemAdapter(this, mlist, Grade,R.layout.item);
+        // Log.d(TAG,"getCount()"+adapter.getCount());
+        // AdapterListView
+        listView.setAdapter(adapter);
+
+        // ListView
+        listView.setOnItemClickListener(new OnItemClickListener() {
+
+            // item Activity
+            public void onItemClick(AdapterView<?> arg0, View arg1,int position, long arg3) {
+                 Application application = adapter.getItem(position);
+                 Log.d(TAG,"onItemClick  " + position + " "+ application.getmApplicationName());
+                 Intent intent = new Intent(MainActivity.this, AppSettings.class);
+                 // 
+                 intent.putExtra("ApplicationName",application.getmApplicationName());
+                 intent.putExtra("ApplicationPkgName", application.getmPkgName()); // 
+                 intent.putExtra("AppSurvivalGrade",application.getAppSurvivalGrade());
+                 intent.putExtra("ApplicationDescFlag",application.getmApplicationDescFlag());
+                 intent.putExtra("ApplicationId",application.getmApplicationId()); // app
+                 // Grade == View
+                 mWhichView = Grade - 1;
+                 // intent.putExtra("position", position);
+                 // startActivity(intent);
+                 startActivityForResult(intent, 1);
+            }
+        });
+        return view;
+    }
+
+    private String getGradeDes(int grade) {
+        if(grade == AppCheckerManager.NO_CHECK_LEVEL){
+            return getResources().getString(R.string.tab_item_never_des);
+        }else{
+            return getResources().getString(R.string.tab_item_des,getDesGradeNumByGrade(grade),getDesGradeDesByGrade(grade));
+        }
+    }
+    //int
+    private int getDesGradeNumByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return num;
+           else return num/60;
+    }
+    //int
+    private String getDesGradeDesByGrade(int level){
+           int num = manager.getLevelTime(level);
+           if(num<60)  return getResources().getString(R.string.unit_min);
+           else if(num == 60) return getResources().getString(R.string.unit_hour);
+           else return getResources().getString(R.string.unit_hours);
+     }
+    
+    // 
+    public void initList() {
+        // mlist
+        mlist = new ArrayList<Application>();
+        // 
+        manager = AppCheckerManager.getInstance();
+        mlist_1 = getApplicationList(getAppPkgNameList(AppCheckerManager.SHORT_LEVEL), this, 1);
+        mlist_2 = getApplicationList(getAppPkgNameList(AppCheckerManager.MEDIUM_LEVEL), this, 2);
+        mlist_3 = getApplicationList(getAppPkgNameList(AppCheckerManager.LONG_LEVEL), this, 3);
+        mlist_4 = getApplicationList(getAppPkgNameList(AppCheckerManager.SUPERLONG_LEVEL), this, 4);
+        mlist_5 = getApplicationList(getAppPkgNameList(AppCheckerManager.NO_CHECK_LEVEL), this, 5);
+        if (mlist_1 != null)
+            mlist.addAll(mlist_1);
+        if (mlist_2 != null)
+            mlist.addAll(mlist_2);
+        if (mlist_3 != null)
+            mlist.addAll(mlist_3);
+        if (mlist_4 != null)
+            mlist.addAll(mlist_4);
+        if (mlist_5 != null)
+            mlist.addAll(mlist_5);
+    }
+
+    //  onRestart()
+    // onRestart() 
+    private boolean misAppSettingChangeFlag = true;
+    public void onRestart() {
+        super.onRestart();
+        Log.d(TAG, "onRestart " + misAppSettingChangeFlag);
+        if (misAppSettingChangeFlag) {
+            initList();
+            initViewPager();
+        }
+        mViewPager.setCurrentItem(mWhichView);
+        misAppSettingChangeFlag = true;
+        initEvent();
+    }
+
+    // onActivityResultAppSettings
+    public void onActivityResult(int resquestCode, int resultCode, Intent intent) {
+        Log.d(TAG, "onActivityResult " + resquestCode + "  " + resultCode);
+        if (resquestCode == 1 && resultCode == 2) {
+             //  
+            for (int i = 0; i < mlist.size(); i++) {
+                 Application application = mlist.get(i);
+                 // ApplicationIdAppItem
+                 if (application.getmApplicationId() == intent.getExtras().getLong("ApplicationId")) {
+                     // 
+                     if ((application.getAppSurvivalGrade() == intent.getExtras().getInt("AppSurvivalGrade"))
+                      && (application.getmApplicationDescFlag() == intent.getExtras().getBoolean("ApplicationDescFlag"))) {
+                         Log.d(TAG, "application ");
+                         misAppSettingChangeFlag = false;
+                      }
+                     // 
+                     else if ((application.getAppSurvivalGrade() != intent.getExtras().getInt("AppSurvivalGrade"))
+                           && (application.getmApplicationDescFlag() != intent.getExtras().getBoolean("ApplicationDescFlag"))) {
+                               Log.d(TAG, "application ");
+                               misAppSettingChangeFlag = true;
+                      }
+                      //  
+                      else if ((application.getAppSurvivalGrade() != intent.getExtras().getInt("AppSurvivalGrade"))
+                            && (application.getmApplicationDescFlag() == intent.getExtras().getBoolean("ApplicationDescFlag"))) {
+                                Log.d(TAG, "application ");
+                                misAppSettingChangeFlag = true;
+                                // 
+                                // manager.setLevel(application.getmPkgName(),intent.getExtras().getInt("AppSurvivalGrade"));
+                      }
+                      //  
+                      else if ((application.getAppSurvivalGrade() == intent.getExtras().getInt("AppSurvivalGrade"))
+                            && (application.getmApplicationDescFlag() != intent.getExtras().getBoolean("ApplicationDescFlag"))) {
+                                Log.d(TAG, "application ");
+                                misAppSettingChangeFlag = true; 
+                                // 
+                                // manager.setAutoBootEnabled(application.getmPkgName(),intent.getExtras().getBoolean("ApplicationDescFlag"));
+                      }
+                       break;
+                  }
+             }
+         }
+    }
+
+    //  List Application List
+    // pramas ArrayList<String> pkgNameList
+    // return ArrayList<Application>;
+    // private ArrayList<String> mpkgNameList1 = new ArrayList<String>();
+    public ArrayList<Application> getApplicationList(List<AppCheckerInfo> AppCheckerInfoList,Context context, int Grade) {
+        PkgManegerTools pkgManegerTools = new PkgManegerTools(AppCheckerInfoList,context, Grade);
+        return pkgManegerTools.getAllApplication();
+    }
+
+    // List<AppCheckerInfo>
+    public List<AppCheckerInfo> getAppPkgNameList(int Grade) {
+        Log.d(TAG, "------List<AppCheckerInfo>------");
+        return manager.getLevelList(Grade);
+    }
+
+    // Menu
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+         // Inflate the menu; this adds items to the action bar if it is present.
+         getMenuInflater().inflate(R.menu.main, menu);
+         return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle action bar item clicks here. The action bar will
+        // automatically handle clicks on the Home/Up button, so long
+        // as you specify a parent activity in AndroidManifest.xml.
+        int id = item.getItemId();
+            if (id == R.id.action_settings) {
+                //
+                manager.resetAppCheckerInfo();
+                Intent intent = new Intent(MainActivity.this, MainActivity.class);
+                startActivity(intent);
+                finish();
+                return true;
+            }
+            return super.onOptionsItemSelected(item);
+    }
+
+}
+
Index: packages/apps/ProcessControl/src/com/topwise/processcontrol/LevelTimeSetting.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/processcontrol/LevelTimeSetting.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/processcontrol/LevelTimeSetting.java	(revision 5734)
@@ -0,0 +1,150 @@
+package com.topwise.processcontrol;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.Toast;
+
+//
+import com.topwise.appcheck.*;
+import android.os.RemoteException;
+
+public class LevelTimeSetting extends Activity  implements OnClickListener{ 
+	private final static String TAG = "Service/OtherActivity";
+	private Button mBtnCancel;
+	private Button mBtnConfirm;
+	private EditText mETLevel1,mETLevel2,mETLevel3,mETLevel4;
+	//
+	private int  mInitTime1;
+	private int  mInitTime2;
+	private int  mInitTime3;
+	private int  mInitTime4;
+	//
+	private int mCurrTime1;
+	private int mCurrTime2;
+	private int mCurrTime3;
+	private int mCurrTime4;
+    
+    private AppCheckerManager manager;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.activity_set_level_time);
+		mBtnCancel = (Button) findViewById(R.id.btncancel);
+		mBtnConfirm = (Button) findViewById(R.id.btnconfirm);
+		mETLevel1 = (EditText) findViewById(R.id.editText1);
+		mETLevel2 = (EditText) findViewById(R.id.editText2);
+		mETLevel3 = (EditText) findViewById(R.id.editText3);
+		mETLevel4 = (EditText) findViewById(R.id.editText4);
+        manager = AppCheckerManager.getInstance();
+		//Hint
+		initTimes();
+		mBtnCancel.setOnClickListener(this);
+		mBtnConfirm.setOnClickListener(this);	
+	}
+	private void initTimes() {
+		// TODO Auto-generated method stub
+		//
+		mInitTime1 = manager.getLevelTime(1);
+		mInitTime2 = manager.getLevelTime(2);
+ 		mInitTime3 = manager.getLevelTime(3);
+		mInitTime4 = manager.getLevelTime(4);
+		//
+		mETLevel1.setHint(mInitTime1+"");
+		mETLevel2.setHint(mInitTime2+"");
+		mETLevel3.setHint(mInitTime3+"");
+		mETLevel4.setHint(mInitTime4+"");
+	}
+	@Override
+	public void onClick(View view) {
+		// TODO Auto-generated method stub
+		//EditText""
+		switch (view.getId()) {
+		case R.id.btncancel:
+			//
+			cancel();
+			break;
+		case R.id.btnconfirm:
+			//
+			if(confrim())  {
+				Toast.makeText(this, "", Toast.LENGTH_LONG).show();
+				finish();
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	//
+	private boolean confrim() {
+		// TODO Auto-generated method stub
+		String string1 = mETLevel1.getText().toString();
+		String string2 = mETLevel2.getText().toString();
+		String string3 = mETLevel3.getText().toString();
+		String string4 = mETLevel4.getText().toString();
+		//
+		if(isEmpty(string1) && isEmpty(string2) && isEmpty(string3) && isEmpty(string4))
+		{
+			Toast.makeText(this, "", Toast.LENGTH_SHORT).show();
+			return false;
+		}
+		//
+		mCurrTime1 = isEmpty(string1) ? mInitTime1 : Integer.valueOf(string1);
+		mCurrTime2 = isEmpty(string2) ? mInitTime2 : Integer.valueOf(string2);
+		mCurrTime3 = isEmpty(string3) ? mInitTime3 : Integer.valueOf(string3);
+		mCurrTime4 = isEmpty(string4) ? mInitTime4 : Integer.valueOf(string4);
+		// 1<2<3<4
+		if(numAnaly())  {
+			Log.d(TAG,"");
+			setCurrLevelTime();
+			return true;
+		}
+		else {
+			Toast.makeText(this, " !\nSh<Me<Lo<SL", Toast.LENGTH_LONG).show();
+			return false;
+		}
+	}
+	private void setCurrLevelTime() {
+		// TODO Auto-generated method stub
+		//
+        manager.setLevelTime(mCurrTime1+","+mCurrTime2+","+mCurrTime3+","+mCurrTime4);
+	}
+	//
+	private boolean numAnaly() {
+		// TODO Auto-generated method stub
+		boolean flag = false;
+		if(mCurrTime1<mCurrTime2 && mCurrTime2 <mCurrTime3 && mCurrTime3<mCurrTime4)
+			flag = true;
+		return flag;
+	}
+	//
+	private void cancel() {
+		// TODO Auto-generated method stub
+		String string1 = mETLevel1.getText().toString();
+		String string2 = mETLevel2.getText().toString();
+		String string3 = mETLevel3.getText().toString();
+		String string4 = mETLevel4.getText().toString();
+		if(!isEmpty(string1) || !isEmpty(string2) || !isEmpty(string3) ||!isEmpty(string4))
+		{
+			//
+			mETLevel1.getText().clear();
+			mETLevel2.getText().clear();
+			mETLevel3.getText().clear();
+			mETLevel4.getText().clear();
+		}
+		else {
+			//
+			finish();
+		}
+	}
+	//
+	public boolean isEmpty(String str){
+		if("".equals(str)) return true;
+		else return false;
+	}
+}
Index: packages/apps/ProcessControl/src/com/topwise/processcontrol/ServiceMenuBroadcastReceiver.java
===================================================================
--- packages/apps/ProcessControl/src/com/topwise/processcontrol/ServiceMenuBroadcastReceiver.java	(revision 0)
+++ packages/apps/ProcessControl/src/com/topwise/processcontrol/ServiceMenuBroadcastReceiver.java	(revision 5734)
@@ -0,0 +1,18 @@
+package com.topwise.processcontrol;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+public class ServiceMenuBroadcastReceiver extends BroadcastReceiver{
+    private final static String TAG ="Service/LevelService" ;
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // TODO Auto-generated method stub
+        Log.d(TAG," "+intent.getAction()+"  "+intent.getDataString());		
+        Intent intentmain = new Intent(context, LevelTimeSetting.class);
+        intentmain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intentmain);
+    }
+}
Index: packages/apps/ProcessControl/res/xml/appsettingspreference.xml
===================================================================
--- packages/apps/ProcessControl/res/xml/appsettingspreference.xml	(revision 0)
+++ packages/apps/ProcessControl/res/xml/appsettingspreference.xml	(revision 5734)
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android" >
+    
+    <PreferenceCategory
+        android:title="@string/appsettingspreference_open_manager"
+        android:key="open_Manager"></PreferenceCategory>
+    <CheckBoxPreference
+        android:key="open_forbid_start"  
+        android:title="@string/appsettingspreference_open_forbid_start"> 
+    </CheckBoxPreference>
+     <PreferenceCategory
+        android:title="@string/appsettingspreference_back_run_manager"
+        android:key="runManager"></PreferenceCategory>
+     <Preference
+         android:summary="@string/appsettingspreference_back_run_manager_des"
+         ></Preference>
+     <CheckBoxPreference
+         android:key="grade_one"
+         android:title="@string/appsettingspreference_grade"></CheckBoxPreference>
+     <CheckBoxPreference
+         android:key="grade_two"
+         android:title="@string/appsettingspreference_grade"></CheckBoxPreference>
+     <CheckBoxPreference
+         android:key="grade_three"
+         android:title="@string/appsettingspreference_grade"></CheckBoxPreference>
+     <CheckBoxPreference
+         android:key="grade_four"
+         android:title="@string/appsettingspreference_grade"></CheckBoxPreference>
+     <CheckBoxPreference
+         android:key="grade_five"
+         android:title="@string/appsettingspreference_grade_five"
+         ></CheckBoxPreference>
+     <!-- 
+     <SwitchPreference
+         android:key="test"
+         android:title="Test"
+         android:summary="test"></SwitchPreference>
+      -->
+    
+
+</PreferenceScreen>
Index: packages/apps/ProcessControl/res/values-w820dp/dimens.xml
===================================================================
--- packages/apps/ProcessControl/res/values-w820dp/dimens.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values-w820dp/dimens.xml	(revision 5734)
@@ -0,0 +1,10 @@
+<resources>
+
+    <!--
+         Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively).
+    -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+
+</resources>
Index: packages/apps/ProcessControl/res/drawable-hdpi/ic_app.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-hdpi/ic_app.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/ic_app.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-hdpi/ic_app.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-hdpi/ic_app.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-hdpi/actionbar_state.xml
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/actionbar_state.xml	(revision 0)
+++ packages/apps/ProcessControl/res/drawable-hdpi/actionbar_state.xml	(revision 5734)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item android:drawable="@color/state_actionbar"></item>
+
+</selector>
Index: packages/apps/ProcessControl/res/drawable-hdpi/ic_default.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-hdpi/ic_default.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/ic_default.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-hdpi/ic_default.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-hdpi/ic_default.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-hdpi/title_bar.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-hdpi/title_bar.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/title_bar.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-hdpi/title_bar.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-hdpi/title_bar.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-hdpi/top_search.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-hdpi/top_search.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/top_search.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-hdpi/top_search.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-hdpi/top_search.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-hdpi/top_add.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-hdpi/top_add.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-hdpi/top_add.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-hdpi/top_add.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-hdpi/top_add.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_app.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_app.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-xxhdpi/ic_app.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-xxhdpi/ic_app.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_app.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_default.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_default.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-xxhdpi/ic_default.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-xxhdpi/ic_default.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-xxhdpi/ic_default.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/menu/appsettings.xml
===================================================================
--- packages/apps/ProcessControl/res/menu/appsettings.xml	(revision 0)
+++ packages/apps/ProcessControl/res/menu/appsettings.xml	(revision 5734)
@@ -0,0 +1,11 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.topwise.processcontrol.Appsettings" >
+
+    <item
+        android:id="@+id/action_settings"
+        android:orderInCategory="100"
+        android:showAsAction="never"
+        android:title="@string/action_appsettings"/>
+
+</menu>
Index: packages/apps/ProcessControl/res/menu/main.xml
===================================================================
--- packages/apps/ProcessControl/res/menu/main.xml	(revision 0)
+++ packages/apps/ProcessControl/res/menu/main.xml	(revision 5734)
@@ -0,0 +1,11 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.topwise.processcontrol.MainActivity" >
+
+    <item
+        android:id="@+id/action_settings"
+        android:orderInCategory="100"
+        android:showAsAction="never"
+        android:title="@string/action_settings"/>
+
+</menu>
Index: packages/apps/ProcessControl/res/values-v11/styles.xml
===================================================================
--- packages/apps/ProcessControl/res/values-v11/styles.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values-v11/styles.xml	(revision 5734)
@@ -0,0 +1,11 @@
+<resources>
+
+    <!--
+        Base application theme for API 11+. This theme completely replaces
+        AppBaseTheme from res/values/styles.xml on API 11+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light">
+        <!-- API 11 theme customizations can go here. -->
+    </style>
+
+</resources>
Index: packages/apps/ProcessControl/res/drawable-ldpi/ic_app.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-ldpi/ic_app.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-ldpi/ic_app.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-ldpi/ic_app.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-ldpi/ic_app.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-ldpi/ic_default.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-ldpi/ic_default.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-ldpi/ic_default.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-ldpi/ic_default.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-ldpi/ic_default.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/values-v14/styles.xml
===================================================================
--- packages/apps/ProcessControl/res/values-v14/styles.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values-v14/styles.xml	(revision 5734)
@@ -0,0 +1,12 @@
+<resources>
+
+    <!--
+        Base application theme for API 14+. This theme completely replaces
+        AppBaseTheme from BOTH res/values/styles.xml and
+        res/values-v11/styles.xml on API 14+ devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- API 14 theme customizations can go here. -->
+    </style>
+
+</resources>
Index: packages/apps/ProcessControl/res/drawable-mdpi/ic_app.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-mdpi/ic_app.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-mdpi/ic_app.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-mdpi/ic_app.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-mdpi/ic_app.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-mdpi/ic_default.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-mdpi/ic_default.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-mdpi/ic_default.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-mdpi/ic_default.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-mdpi/ic_default.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-xhdpi/ic_app.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-xhdpi/ic_app.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-xhdpi/ic_app.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-xhdpi/ic_app.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-xhdpi/ic_app.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/drawable-xhdpi/ic_default.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/ProcessControl/res/drawable-xhdpi/ic_default.png
===================================================================
--- packages/apps/ProcessControl/res/drawable-xhdpi/ic_default.png	(revision 5726)
+++ packages/apps/ProcessControl/res/drawable-xhdpi/ic_default.png	(revision 5734)

Property changes on: packages/apps/ProcessControl/res/drawable-xhdpi/ic_default.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/ProcessControl/res/layout/tab_list_demo.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/tab_list_demo.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/tab_list_demo.xml	(revision 5734)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <TextView
+        android:id="@+id/item_desc"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/tab_list_demo_textview" />
+
+    <ListView
+        android:id="@+id/listView1"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+    </ListView>
+
+</LinearLayout>
Index: packages/apps/ProcessControl/res/layout/activity_set_level_time.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/activity_set_level_time.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/activity_set_level_time.xml	(revision 5734)
@@ -0,0 +1,135 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical" >
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+        
+      <TextView
+          android:id="@+id/title"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:layout_centerHorizontal="true"
+          android:text="@string/title_level"
+          android:textSize="24sp" />
+        
+    </RelativeLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+        <TextView
+            android:id="@+id/textView1"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/short_level" />
+        <EditText
+            android:id="@+id/editText1"
+            android:layout_width="100dp"
+            android:layout_height="match_parent"
+            android:numeric="decimal"
+            android:ems="10" >
+        </EditText>        
+        <TextView
+            android:id="@+id/textView11"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/unit_level" />      
+    </LinearLayout>
+    
+   
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+        <TextView
+            android:id="@+id/textView2"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/medium_level" />
+        <EditText
+            android:id="@+id/editText2"
+            android:layout_width="100dp"
+            android:layout_height="match_parent"
+            android:numeric="decimal"
+            android:ems="10" >
+        </EditText>        
+            <TextView
+            android:id="@+id/textView22"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/unit_level" />      
+    </LinearLayout>
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+        <TextView
+            android:id="@+id/textView3"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/long_level" />
+        <EditText
+            android:id="@+id/editText3"
+            android:layout_width="100dp"
+            android:layout_height="match_parent"
+            android:numeric="decimal"
+            android:ems="10" >
+        </EditText>        
+            <TextView
+            android:id="@+id/textView33"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/unit_level" />      
+    </LinearLayout>
+     <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+        <TextView
+            android:id="@+id/textView4"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/superlong_level" />
+        <EditText
+            android:id="@+id/editText4"
+            android:layout_width="100dp"
+            android:layout_height="match_parent"
+            android:numeric="decimal"
+            android:ems="10" >
+        </EditText>        
+            <TextView
+            android:id="@+id/textView44"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:textSize="18sp"
+            android:text="@string/unit_level" />      
+    </LinearLayout>
+    
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+            <Button android:id="@+id/btncancel"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_alignParentLeft="true"
+                android:layout_marginLeft="40dp"
+                android:text="@string/cancel_level"/>
+            <Button android:id="@+id/btnconfirm"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_alignParentRight="true"
+                android:layout_marginRight="40dp"
+                android:text="@string/confrim_level"/>
+
+    </RelativeLayout>
+    
+
+</LinearLayout>
Index: packages/apps/ProcessControl/res/layout/activity_appsettings.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/activity_appsettings.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/activity_appsettings.xml	(revision 5734)
@@ -0,0 +1,16 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context="com.topwise.processcontrol.AppSettings" >
+
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/hello_world" />
+
+</RelativeLayout>
Index: packages/apps/ProcessControl/res/layout/item.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/item.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/item.xml	(revision 5734)
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent" 
+    android:layout_height="60dip"
+    android:minHeight="?android:attr/listPreferredItemHeight"
+    android:gravity="center_vertical"
+    android:orientation = "horizontal"
+    android:paddingRight="?android:attr/scrollbarSize">
+    
+    <RelativeLayout 
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:layout_marginLeft="12dip"
+            android:gravity="center_vertical"
+            android:layout_weight="1">
+    
+        <ImageView android:id = "@+id/item_image"
+            android:layout_marginTop="10dip"
+            android:layout_height = "40dip"
+            android:layout_width = "40dip"
+            android:gravity="center_vertical"
+            android:scaleType="centerInside"
+            android:background="@drawable/ic_default"/>
+        
+        <TextView android:id="@+id/item_title"
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:layout_marginStart = "12dip"
+            android:layout_toEndOf = "@id/item_image"
+            android:gravity="center_vertical"
+            android:singleLine="true"
+            android:ellipsize="marquee"
+            android:textSize="18sp"
+            android:text="@string/item_app_neme"/>
+
+        <TextView
+            android:id="@+id/item_textdesc"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignLeft="@+id/item_title"
+            android:layout_alignParentBottom="true"
+            android:textSize="12sp"
+            android:textColor="#707"
+            android:text="@string/item_app_audo" />
+
+    </RelativeLayout>
+
+
+</LinearLayout>
Index: packages/apps/ProcessControl/res/layout/title_layout.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/title_layout.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/title_layout.xml	(revision 5734)
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="72dp"
+    android:background="#000000" >
+<!--android:background="@drawable/title_bar"-->
+    <TextView
+        android:id="@+id/textView1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:layout_marginLeft="20dp"
+        
+        android:textColor="#000000"
+        android:textSize="20sp"
+        android:textStyle="bold" />
+
+    <!--<ImageButton
+        android:id="@+id/top_add"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:background="@drawable/top_add" 
+        android:onClick="onTitleClick"
+       />-->
+
+    <!--<ImageButton
+        android:id="@+id/top_search"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignBottom="@+id/textView1"
+        android:layout_alignParentLeft="true"
+        android:layout_marginLeft="14dp"
+        android:background="@drawable/top_search"
+       />-->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:layout_alignParentBottom="true"
+        android:layout_alignParentLeft="true"
+        android:background="#e9e7ef" >
+    </LinearLayout>
+
+
+</RelativeLayout>
Index: packages/apps/ProcessControl/res/layout/activity_main.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/activity_main.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/activity_main.xml	(revision 5734)
@@ -0,0 +1,20 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
+        xmlns:tools="http://schemas.android.com/tools"  
+        android:layout_width="match_parent"  
+        android:layout_height="match_parent"  
+        android:orientation="vertical" >  
+
+       <include layout="@layout/title_layout" />  
+       <include layout="@layout/tab_layout" />  
+        <android.support.v4.view.ViewPager  
+            android:id="@+id/id_viewpage"  
+            android:layout_width="fill_parent"  
+            android:layout_height="0dp"  
+            android:layout_weight="1" 
+            android:background="#ffffff">  
+        </android.support.v4.view.ViewPager>  
+       
+       
+       
+      
+    </LinearLayout>
Index: packages/apps/ProcessControl/res/layout/tab_layout.xml
===================================================================
--- packages/apps/ProcessControl/res/layout/tab_layout.xml	(revision 0)
+++ packages/apps/ProcessControl/res/layout/tab_layout.xml	(revision 5734)
@@ -0,0 +1,109 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="49dp"
+    android:orientation="vertical" 
+    android:background="#ffffff">
+    <LinearLayout
+    android:layout_width="match_parent"
+    android:layout_height="48dp" 
+    android:orientation="horizontal" 
+    android:background="#ffffff"
+    >
+    <RelativeLayout
+        android:id="@+id/ly_tv_15"
+        android:layout_width="0dp"
+        android:layout_height="match_parent"
+        android:layout_weight="1"
+        android:orientation="horizontal" >
+
+    <TextView
+        android:id="@+id/tv_15"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:gravity="center"
+        android:text="@string/tab_item"
+        android:textSize="18sp" />
+
+    </RelativeLayout>
+    
+    <RelativeLayout 
+        android:id="@+id/ly_tv_1"
+        android:layout_width="0dp" 
+        android:layout_height="match_parent"
+        android:layout_weight="1">
+    <TextView
+        android:id="@+id/tv_1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:gravity="center"
+        android:textSize="18sp"
+        android:text="@string/tab_item" />
+    </RelativeLayout>
+    
+  <RelativeLayout 
+        android:id="@+id/ly_tv_3"
+        android:layout_width="0dp" 
+        android:layout_height="match_parent"
+        android:layout_weight="1">
+
+    <TextView
+        android:id="@+id/tv_3"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:gravity="center"
+         android:textSize="18sp"
+        android:text="@string/tab_item" />
+    </RelativeLayout>
+
+    <RelativeLayout 
+        android:id="@+id/ly_tv_24"
+        android:layout_width="0dp" 
+        android:layout_height="match_parent"
+        android:layout_weight="1">
+
+    <TextView
+        android:id="@+id/tView_24"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:gravity="center"
+        android:textSize="18sp"
+        android:text="@string/tab_item"/>
+    </RelativeLayout>
+
+    
+    <RelativeLayout 
+        android:id="@+id/ly_tv_never"
+        android:layout_width="0dp" 
+        android:layout_height="match_parent"
+        android:layout_weight="1">
+
+    <TextView
+        android:id="@+id/tv_never"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:gravity="center"
+        android:textSize="18sp"
+        android:text="@string/tab_item_never" />
+    </RelativeLayout>
+        
+    </LinearLayout>
+    <LinearLayout 
+         android:layout_width="match_parent"
+         android:layout_height="1dp" 
+          android:background="#e9e7ef"
+        ></LinearLayout>
+    
+  
+
+
+
+
+
+
+</LinearLayout>
Index: packages/apps/ProcessControl/res/values-zh-rCN/strings.xml
===================================================================
--- packages/apps/ProcessControl/res/values-zh-rCN/strings.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values-zh-rCN/strings.xml	(revision 5734)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <string name="app_name"></string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings"></string>
+    <string name="action_appsettings"></string>
+
+    <!-- 1 -->
+    <string name="tab_item"><xliff:g id="grade">%1$d</xliff:g><xliff:g id="unit">%2$s</xliff:g></string>
+    <string name="tab_item_des"><xliff:g id="grade">%1$d</xliff:g><xliff:g id="unit">%2$s</xliff:g>"</string>
+    <string name="tab_item_never"></string>
+    <string name="tab_item_never_des"></string>
+    <string name="title_activity_appsettings">Appsettings</string>
+    <!-- item -->
+    <string name="item_app_neme">NAME</string>
+     <string name="item_app_audo"></string>
+     
+     <!-- tab_list_demo -->
+     <string name="tab_list_demo_textview">ItemListApp</string>
+
+    <!--appsettingspreference-->
+    <string name="appsettingspreference_open_manager"></string>
+    <string name="appsettingspreference_open_forbid_start"></string>
+    <string name="appsettingspreference_back_run_manager"></string>
+    <string name="appsettingspreference_back_run_manager_des"></string>
+    <string name="appsettingspreference_grade"><xliff:g id="grade">%1$d</xliff:g> <xliff:g id="unit">%2$s</xliff:g></string>
+    <string name="appsettingspreference_grade_five"></string>
+
+
+    <string name="unit_m"></string>
+    <string name="unit_h"></string>
+    <string name="unit_min"></string>
+    <string name="unit_hour"></string>
+    <string name="unit_hours"></string>
+
+</resources>
+
+
+
+
+
+
+
Index: packages/apps/ProcessControl/res/values/colors.xml
===================================================================
--- packages/apps/ProcessControl/res/values/colors.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values/colors.xml	(revision 5734)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <color name="app_overall">#FF3600</color>
+    <!---->
+    <color name="state_background">#80808080</color>
+    <!--ActionBar-->
+    <color name="state_actionbar">#00000000</color>
+ 
+</resources>
Index: packages/apps/ProcessControl/res/values/styles.xml
===================================================================
--- packages/apps/ProcessControl/res/values/styles.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values/styles.xml	(revision 5734)
@@ -0,0 +1,29 @@
+<resources>
+
+    <!--
+        Base application theme, dependent on API level. This theme is replaced
+        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
+    -->
+    <style name="AppBaseTheme" parent="android:Theme.Light">
+        <!--
+            Theme customizations available in newer API levels can go in
+            res/values-vXX/styles.xml, while customizations related to
+            backward-compatibility can go here.
+        -->
+    </style>
+
+    <!-- Application theme. -->
+    <style name="AppTheme" parent="AppBaseTheme">
+        
+    </style>
+
+    <style name="myActionBarStyle" parent="android:Widget.ActionBar" >  
+        <item name="android:background">#ffffff</item>  
+        <item name="android:titleTextStyle">@style/AcBar_titleStyle</item>  
+    </style>
+    <style name="AcBar_titleStyle">  
+        <item name="android:textSize">24sp</item>  
+        <item name="android:textColor">#000000</item>  
+    </style>
+
+</resources>
Index: packages/apps/ProcessControl/res/values/strings.xml
===================================================================
--- packages/apps/ProcessControl/res/values/strings.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values/strings.xml	(revision 5734)
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <string name="app_name">ProcessControl</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Restore the default Settings</string>
+    <string name="action_appsettings">WELCOME TO YOU</string>
+    <string name="title_activity_set_level_time">set test time</string>
+
+
+    <!-- 1 -->
+    <string name="tab_item"><xliff:g id="grade">%1$d</xliff:g><xliff:g id="unit">%2$s</xliff:g></string>
+    <string name="tab_item_des">To save the memory of your phone and ensure system running smoothly, the following applications will be forced to shut down by the system in the background after running for <xliff:g id="grade">%1$d</xliff:g> <xliff:g id="unit">%2$s</xliff:g>.</string>
+    <string name="tab_item_never">Never</string>
+    <string name="tab_item_never_des">The following applications will not be forced to shut down by system.</string>
+
+    <string name="title_activity_appsettings">Appsettings</string>
+    <!-- item -->
+    <string name="item_app_neme">Application Name</string>
+    <string name="item_app_audo">Prohibit when the phone is switched on</string>
+     
+     <!-- tab_list_demo -->
+    <string name="tab_list_demo_textview">this ItemList App Log</string>
+    
+    <!--appsettingspreference-->
+    <string name="appsettingspreference_open_manager">Boot Manager</string>
+    <string name="appsettingspreference_open_forbid_start">Ban starting with the phone on</string>
+    <string name="appsettingspreference_back_run_manager">Run in the background manager</string>
+    <string name="appsettingspreference_back_run_manager_des">Please select the time that the application runs continuously in the background. System will force to shut down the application which is running in the background after the setting time. If you open the application manually, the system will recalculate the time running in the background.</string>
+    <string name="appsettingspreference_grade"><xliff:g id="grade">%1$d</xliff:g>  <xliff:g id="unit">%2$s</xliff:g></string>
+    <string name="appsettingspreference_grade_five">Never</string>
+
+    <string name="unit_m">M</string>
+    <string name="unit_h">H</string>
+    <string name="unit_min">min</string>
+    <string name="unit_hour">hour</string>
+    <string name="unit_hours">hours</string>
+
+    <!--  SetLevelTime  -->
+    <string name="title_level">Set test time</string>
+    <string name="short_level">Short level</string>
+    <string name="medium_level">Medium level</string>
+    <string name="long_level">Long level</string>
+    <string name="superlong_level">Super long</string>
+    <string name="unit_level">min</string>
+    <string name="cancel_level">qiut</string>
+    <string name="confrim_level">ok</string>
+    
+
+</resources>
Index: packages/apps/ProcessControl/res/values/dimens.xml
===================================================================
--- packages/apps/ProcessControl/res/values/dimens.xml	(revision 0)
+++ packages/apps/ProcessControl/res/values/dimens.xml	(revision 5734)
@@ -0,0 +1,7 @@
+<resources>
+
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+
+</resources>
